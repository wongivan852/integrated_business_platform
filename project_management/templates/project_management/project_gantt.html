{% extends 'project_management/base.html' %}
{% load static %}

{% block page_title %}{{ project.name }} - Gantt Chart{% endblock %}

{% block breadcrumb_items %}
<li class="breadcrumb-item">
    <a href="{% url 'project_management:project_detail' project.pk %}">{{ project.name }}</a>
</li>
<li class="breadcrumb-item active" aria-current="page">Gantt Chart</li>
{% endblock %}

{% block page_heading %}
    <i class="fas fa-chart-bar"></i> {{ project.name }}
{% endblock %}

{% block page_subtitle %}
<div class="d-flex align-items-center gap-3">
    <span class="badge bg-light text-dark">Gantt Chart View</span>
    <span class="badge bg-success text-white">✓ Updated 16:45</span>
    <span class="status-badge {{ project.status }}">{{ project.get_status_display }}</span>
    {% if timeline_stats %}
    <span class="text-muted small">
        <i class="far fa-calendar"></i>
        {{ timeline_stats.start_date|date:"M d" }} - {{ timeline_stats.end_date|date:"M d, Y" }}
        ({{ timeline_stats.total_duration }} days)
    </span>
    {% endif %}
</div>
{% endblock %}

{% block header_actions %}
<div class="view-switcher me-3">
    <a href="{% url 'project_management:project_kanban' project.pk %}"
       class="btn">
        <i class="fas fa-columns"></i> Kanban
    </a>
    <a href="{% url 'project_management:project_gantt' project.pk %}"
       class="btn active">
        <i class="fas fa-chart-bar"></i> Gantt
    </a>
</div>

{% if is_admin %}
<div class="btn-group me-2">
    <button class="btn btn-outline-light" onclick="showCreateBaselineModal()">
        <i class="fas fa-save"></i> Save Baseline
    </button>
    <button class="btn btn-outline-light" onclick="showDependencyModal()">
        <i class="fas fa-link"></i> Add Dependency
    </button>
</div>
{% endif %}

<a href="{% url 'project_management:project_detail' project.pk %}" class="btn btn-outline-light">
    <i class="fas fa-arrow-left"></i> Back
</a>
{% endblock %}

{% block page_content %}
<style>
    /* Make Gantt chart page full-width for better date visibility */
    .container {
        max-width: 100% !important;
        padding-left: 15px;
        padding-right: 15px;
    }
</style>

<!-- Gantt Chart Toolbar -->
<div class="card project-card mb-3">
    <div class="card-body py-2">
        <div class="row align-items-center">
            <div class="col-md-6">
                <div class="btn-group btn-group-sm" role="group">
                    <input type="radio" class="btn-check" name="viewMode" id="viewDay" value="day">
                    <label class="btn btn-outline-secondary" for="viewDay">Day</label>

                    <input type="radio" class="btn-check" name="viewMode" id="viewWeek" value="week">
                    <label class="btn btn-outline-secondary" for="viewWeek">Week</label>

                    <input type="radio" class="btn-check" name="viewMode" id="viewMonth" value="month" checked>
                    <label class="btn btn-outline-secondary" for="viewMonth">Month</label>

                    <input type="radio" class="btn-check" name="viewMode" id="viewYear" value="year">
                    <label class="btn btn-outline-secondary" for="viewYear">Year</label>
                </div>

                <!-- Force Full Year Button -->
                <button class="btn btn-sm btn-warning ms-2" id="forceFullYear" title="Force timeline to show full year 2025">
                    <i class="fas fa-expand-arrows-alt"></i> Force Full Year
                </button>

                <div class="btn-group btn-group-sm ms-3" role="group">
                    <button class="btn btn-outline-secondary" onclick="gantt.scrollToToday()">
                        <i class="fas fa-calendar-day"></i> Today
                    </button>
                    <button class="btn btn-outline-secondary" onclick="gantt.ext.fullscreen.toggle()">
                        <i class="fas fa-expand"></i>
                    </button>
                </div>

                <!-- Search Box -->
                <div class="d-inline-block ms-3" style="width: 250px;">
                    <div class="input-group input-group-sm">
                        <input type="text"
                               class="form-control"
                               id="taskSearch"
                               placeholder="Search tasks..."
                               autocomplete="off">
                        <button class="btn btn-outline-secondary" type="button" id="searchBtn" onclick="searchTasks()">
                            <i class="fas fa-search"></i>
                        </button>
                        <button class="btn btn-outline-secondary" type="button" id="clearSearchBtn" onclick="clearSearch()" style="display:none;">
                            <i class="fas fa-times"></i>
                        </button>
                    </div>
                    <small id="searchResults" class="text-muted" style="display:none;"></small>
                </div>
            </div>

            <div class="col-md-6 text-end">
                <div class="form-check form-check-inline form-switch">
                    <input class="form-check-input" type="checkbox" id="showCritical" checked>
                    <label class="form-check-label" for="showCritical">
                        <i class="fas fa-route text-danger"></i> Critical Path
                    </label>
                </div>

                <div class="form-check form-check-inline form-switch">
                    <input class="form-check-input" type="checkbox" id="showDeps" checked>
                    <label class="form-check-label" for="showDeps">
                        <i class="fas fa-project-diagram"></i> Dependencies
                    </label>
                </div>

                <div class="form-check form-check-inline form-switch">
                    <input class="form-check-input" type="checkbox" id="showProgress" checked>
                    <label class="form-check-label" for="showProgress">
                        <i class="fas fa-tasks"></i> Progress
                    </label>
                </div>

                <!-- Chart Height Control -->
                <div class="btn-group btn-group-sm ms-3" role="group">
                    <button class="btn btn-outline-secondary" type="button" onclick="adjustChartHeight('decrease')" title="Decrease Height">
                        <i class="fas fa-compress-alt"></i>
                    </button>
                    <button class="btn btn-outline-secondary" type="button" id="currentHeightBtn" style="min-width: 80px;">
                        700px
                    </button>
                    <button class="btn btn-outline-secondary" type="button" onclick="adjustChartHeight('increase')" title="Increase Height">
                        <i class="fas fa-expand-alt"></i>
                    </button>
                </div>

                {% if baselines %}
                <select class="form-select form-select-sm d-inline-block w-auto ms-2" id="baselineSelect">
                    <option value="">No Baseline</option>
                    {% for baseline in baselines %}
                    <option value="{{ baseline.pk }}" {% if baseline.pk|stringformat:"s" == selected_baseline_id %}selected{% endif %}>
                        {{ baseline.name }}
                    </option>
                    {% endfor %}
                </select>
                {% endif %}
            </div>
        </div>
    </div>
</div>

<!-- Project Statistics -->
{% if timeline_stats %}
<div class="row mb-3">
    <div class="col-md-3">
        <div class="card project-card">
            <div class="card-body text-center py-3">
                <h6 class="text-muted mb-1">Total Tasks</h6>
                <h3 class="mb-0">{{ timeline_stats.total_tasks }}</h3>
                <small class="text-success">{{ timeline_stats.completed_tasks }} completed</small>
            </div>
        </div>
    </div>

    <div class="col-md-3">
        <div class="card project-card">
            <div class="card-body text-center py-3">
                <h6 class="text-muted mb-1">Average Progress</h6>
                <h3 class="mb-0">{{ timeline_stats.average_progress }}%</h3>
                <div class="progress mt-2" style="height: 5px;">
                    <div class="progress-bar bg-success" style="width: {{ timeline_stats.average_progress }}%"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="col-md-3">
        <div class="card project-card">
            <div class="card-body text-center py-3">
                <h6 class="text-muted mb-1">In Progress</h6>
                <h3 class="mb-0">{{ timeline_stats.in_progress_tasks }}</h3>
                <small class="text-muted">{{ timeline_stats.not_started_tasks }} not started</small>
            </div>
        </div>
    </div>

    <div class="col-md-3">
        <div class="card project-card">
            <div class="card-body text-center py-3">
                <h6 class="text-muted mb-1">Overdue Tasks</h6>
                <h3 class="mb-0 {% if timeline_stats.overdue_tasks > 0 %}text-danger{% endif %}">
                    {{ timeline_stats.overdue_tasks }}
                </h3>
                <small class="text-muted">{{ timeline_stats.completion_percentage|floatformat:0 }}% complete</small>
            </div>
        </div>
    </div>
</div>
{% endif %}

<!-- Gantt Chart Container -->
<div class="card project-card">
    <div class="card-body p-0">
        <div id="gantt_here" style="width:100%; height:700px; overflow: hidden; transition: height 0.3s ease;"></div>
    </div>
</div>

<!-- Critical Path Tasks -->
{% if critical_path %}
<div class="card project-card mt-3">
    <div class="card-header bg-white">
        <h5 class="mb-0">
            <i class="fas fa-route text-danger"></i> Critical Path Tasks ({{ critical_path|length }})
        </h5>
    </div>
    <div class="card-body">
        <p class="text-muted">
            These tasks are on the critical path. Any delay in these tasks will delay the entire project.
        </p>
        <div class="row">
            {% for task in tasks %}
            {% if task.id in critical_path %}
            <div class="col-md-6 mb-2">
                <div class="d-flex align-items-center">
                    <i class="fas fa-exclamation-triangle text-danger me-2"></i>
                    <a href="{% url 'project_management:task_detail' project.pk task.pk %}" class="text-decoration-none">
                        <strong>{{ task.task_code }}</strong> - {{ task.title }}
                    </a>
                </div>
            </div>
            {% endif %}
            {% endfor %}
        </div>
    </div>
</div>
{% endif %}

<!-- Baseline Comparison -->
{% if baseline_comparison %}
<div class="card project-card mt-3">
    <div class="card-header bg-white">
        <h5 class="mb-0">
            <i class="fas fa-balance-scale"></i> Baseline Comparison: {{ baseline_comparison.baseline.name }}
        </h5>
    </div>
    <div class="card-body">
        <div class="row mb-3">
            <div class="col-md-4 text-center">
                <div class="p-3 bg-success bg-opacity-10 rounded">
                    <h4 class="text-success mb-0">{{ baseline_comparison.total_ahead }}</h4>
                    <small class="text-muted">Tasks Ahead of Schedule</small>
                </div>
            </div>
            <div class="col-md-4 text-center">
                <div class="p-3 bg-info bg-opacity-10 rounded">
                    <h4 class="text-info mb-0">{{ baseline_comparison.total_on_track }}</h4>
                    <small class="text-muted">Tasks On Track</small>
                </div>
            </div>
            <div class="col-md-4 text-center">
                <div class="p-3 bg-danger bg-opacity-10 rounded">
                    <h4 class="text-danger mb-0">{{ baseline_comparison.total_behind }}</h4>
                    <small class="text-muted">Tasks Behind Schedule</small>
                </div>
            </div>
        </div>

        <div class="table-responsive">
            <table class="table table-sm table-hover">
                <thead>
                    <tr>
                        <th>Task</th>
                        <th>Current Dates</th>
                        <th>Baseline Dates</th>
                        <th>Variance</th>
                        <th>Status</th>
                    </tr>
                </thead>
                <tbody>
                    {% for comparison in baseline_comparison.comparisons %}
                    <tr>
                        <td>
                            <strong>{{ comparison.task.task_code }}</strong><br>
                            <small class="text-muted">{{ comparison.task.title|truncatewords:5 }}</small>
                        </td>
                        <td>
                            {% if comparison.task.start_date %}
                            {{ comparison.task.start_date|date:"M d" }} - {{ comparison.task.end_date|date:"M d" }}
                            {% else %}
                            <span class="text-muted">Not scheduled</span>
                            {% endif %}
                        </td>
                        <td>
                            {{ comparison.baseline_task.start_date|date:"M d" }} - {{ comparison.baseline_task.end_date|date:"M d" }}
                        </td>
                        <td>
                            {% if comparison.end_variance %}
                            <span class="badge {% if comparison.is_ahead %}bg-success{% elif comparison.is_behind %}bg-danger{% else %}bg-info{% endif %}">
                                {{ comparison.end_variance|stringformat:"+d" }} days
                            </span>
                            {% endif %}
                        </td>
                        <td>
                            {% if comparison.is_ahead %}
                            <i class="fas fa-check-circle text-success"></i> Ahead
                            {% elif comparison.is_behind %}
                            <i class="fas fa-exclamation-circle text-danger"></i> Behind
                            {% else %}
                            <i class="fas fa-minus-circle text-info"></i> On Track
                            {% endif %}
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>
</div>
{% endif %}

<!-- Create Baseline Modal -->
<div class="modal fade" id="createBaselineModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-save"></i> Create Baseline
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="baselineName" class="form-label">Baseline Name</label>
                    <input type="text" class="form-control" id="baselineName"
                           placeholder="e.g., Initial Plan, Sprint 1 Baseline">
                </div>
                <div class="mb-3">
                    <label for="baselineDescription" class="form-label">Description (Optional)</label>
                    <textarea class="form-control" id="baselineDescription" rows="3"
                              placeholder="What does this baseline represent?"></textarea>
                </div>
                <div class="alert alert-info mb-0">
                    <i class="fas fa-info-circle"></i>
                    This will save the current schedule (start dates, end dates, duration, and progress) for all tasks.
                    You can later compare the actual schedule against this baseline.
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="createBaseline()">
                    <i class="fas fa-save"></i> Create Baseline
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Add Dependency Modal -->
<div class="modal fade" id="dependencyModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-link"></i> Add Task Dependency
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label for="predecessorTask" class="form-label">Predecessor Task (From)</label>
                    <select class="form-select" id="predecessorTask">
                        <option value="">Select a task...</option>
                        {% for task in tasks %}
                        <option value="{{ task.pk }}">{{ task.task_code }} - {{ task.title }}</option>
                        {% endfor %}
                    </select>
                    <small class="form-text text-muted">This task must finish before the successor can start</small>
                </div>

                <div class="mb-3">
                    <label for="successorTask" class="form-label">Successor Task (To)</label>
                    <select class="form-select" id="successorTask">
                        <option value="">Select a task...</option>
                        {% for task in tasks %}
                        <option value="{{ task.pk }}">{{ task.task_code }} - {{ task.title }}</option>
                        {% endfor %}
                    </select>
                    <small class="form-text text-muted">This task depends on the predecessor</small>
                </div>

                <div class="mb-3">
                    <label for="dependencyType" class="form-label">Dependency Type</label>
                    <select class="form-select" id="dependencyType">
                        <option value="FS">Finish-to-Start (FS)</option>
                        <option value="SS">Start-to-Start (SS)</option>
                        <option value="FF">Finish-to-Finish (FF)</option>
                        <option value="SF">Start-to-Finish (SF)</option>
                    </select>
                </div>

                <div class="mb-3">
                    <label for="lagDays" class="form-label">Lag Days</label>
                    <input type="number" class="form-control" id="lagDays" value="0"
                           placeholder="0">
                    <small class="form-text text-muted">Positive for delay, negative for overlap</small>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="addDependency()">
                    <i class="fas fa-link"></i> Add Dependency
                </button>
            </div>
        </div>
    </div>
</div>

{% endblock %}

{% block page_js %}
<!-- dhtmlxGantt Library -->
<script src="https://cdn.dhtmlx.com/gantt/edge/dhtmlxgantt.js"></script>
<link href="https://cdn.dhtmlx.com/gantt/edge/dhtmlxgantt.css" rel="stylesheet">

<style>
    /* Gantt Chart Custom Styles */
    .gantt_task_line.critical_task {
        background-color: #dc3545 !important;
        border: 2px solid #bd2130 !important;
    }

    .gantt_task_line.critical_task .gantt_task_progress {
        background-color: #a71d2a !important;
    }

    .gantt_grid_head_cell,
    .gantt_grid_data .gantt_cell {
        font-size: 14px;
    }

    .gantt_task_cell.week_end {
        background-color: #f8f9fa;
    }

    .gantt_grid_data .gantt_row.gantt_selected,
    .gantt_grid_data .gantt_row.odd.gantt_selected,
    .gantt_task_row.gantt_selected {
        background-color: #e3f2fd;
    }

    .gantt_link_arrow {
        z-index: 100;
    }

    /* Milestone styling */
    .gantt_task_line.milestone {
        background-color: #ffc107;
        border: 2px solid #e0a800;
        transform: rotate(45deg);
        width: 20px !important;
        height: 20px !important;
        margin-left: -10px;
        margin-top: -3px;
    }

    /* Progress bar colors */
    .gantt_task_progress {
        background: #198754 !important;
    }

    /* Baseline comparison */
    .gantt_task_line.baseline {
        opacity: 0.5;
        background-color: #6c757d !important;
    }

    /* Lightbox (dialog) positioning and styling */
    .gantt_cal_light {
        position: fixed !important;
        top: 50% !important;
        left: 50% !important;
        transform: translate(-50%, -50%) !important;
        z-index: 10000 !important;
        max-height: 80vh !important;
        overflow-y: auto !important;
    }

    .gantt_cal_cover {
        z-index: 9999 !important;
    }

    /* Make textarea fields in lightbox larger */
    .gantt_cal_light textarea {
        min-height: 60px !important;
        font-size: 14px !important;
    }

    /* Ensure predecessors section content is fully visible and scrollable */
    .gantt_cal_ltext {
        overflow-y: auto !important;
        overflow-x: hidden !important;
        max-height: 100% !important;
        padding: 10px !important;
        box-sizing: border-box !important;
    }

    /* Improved grid styling for bilingual text */
    .gantt_grid_data .gantt_cell {
        vertical-align: middle !important;
        padding: 5px 8px !important;
    }

    .gantt_grid_head_cell {
        font-weight: 600 !important;
        background: #f8f9fa !important;
        border-bottom: 2px solid #dee2e6 !important;
    }

    /* Better tree indentation */
    .gantt_tree_indent {
        width: 20px !important;
    }

    /* Grid column resizer */
    .gantt_grid_head_cell .gantt_grid_head_cell_resize {
        cursor: col-resize !important;
    }

    /* Scrollbar styling */
    .gantt_layout_cell_border_right {
        border-right: 2px solid #dee2e6 !important;
    }

    /* Task row hover effect */
    .gantt_grid_data .gantt_row:hover {
        background-color: #f1f3f5 !important;
    }

    /* Ensure grid stays fixed during timeline scroll */
    .gantt_grid {
        position: relative;
        overflow-x: hidden !important;
    }

    .gantt_task {
        overflow-x: auto !important;
    }

    /* Make sure horizontal scrollbar only affects timeline */
    .gantt_hor_scroll {
        margin-left: 605px;
    }

    /* Ensure proper scrolling behavior */
    .gantt_layout_root {
        height: 100% !important;
    }

    .gantt_layout_cell {
        height: 100% !important;
    }

    /* Vertical scrollbar styling */
    .gantt_ver_scroll {
        width: 17px !important;
    }

    /* Make sure content can scroll */
    .gantt_grid_data,
    .gantt_data_area,
    .gantt_task_bg {
        position: relative !important;
    }

    /* Fix text color on task bars for better readability */
    .gantt_task_line .gantt_task_content {
        color: #ffffff !important;
        font-weight: 500 !important;
        text-shadow: 0 1px 2px rgba(0,0,0,0.3) !important;
        font-size: 13px !important;
    }

    /* Ensure task text is visible on all colored bars */
    .gantt_task_line {
        color: #ffffff !important;
    }

    /* Search result highlighting */
    .gantt_row.search_match {
        background-color: #fff3cd !important;
        border-left: 3px solid #ffc107;
    }

    .gantt_task_line.search_match {
        box-shadow: 0 0 8px 2px #ffc107 !important;
        border: 2px solid #ffc107 !important;
    }

    .gantt_row.search_selected {
        background-color: #cfe2ff !important;
        border-left: 3px solid #0d6efd;
    }

    .gantt_task_line.search_selected {
        box-shadow: 0 0 10px 3px #0d6efd !important;
        border: 2px solid #0d6efd !important;
    }

    /* Removed marker hiding CSS - no longer needed */

    /* Hide tasks with the gantt_hidden_task class */
    .gantt_hidden_task,
    .gantt_task_line.gantt_hidden_task,
    .gantt_task_row.gantt_hidden_row {
        display: none !important;
        visibility: hidden !important;
        height: 0 !important;
        max-height: 0 !important;
    }

    /* Hide the row in grid for hidden tasks */
    .gantt_row.gantt_hidden_row {
        height: 0 !important;
        line-height: 0 !important;
        display: none !important;
    }

    /* Removed timeline marker styles - no longer needed */

    /* Hide boundary tasks completely */
    .gantt_boundary_hidden,
    .gantt_task_line.gantt_boundary_hidden,
    .gantt_row.gantt_boundary_hidden {
        opacity: 0 !important;
        height: 1px !important;
        min-height: 0 !important;
        pointer-events: none !important;
    }

    /* Hide timeline forcing tasks completely */
    .timeline_hidden_task,
    .gantt_task_line.timeline_hidden_task,
    .gantt_row.timeline_hidden_task,
    [task_id^="_tl_"],
    .gantt_row[task_id^="_tl_"],
    .gantt_task_row[task_id^="_tl_"],
    .gantt_task_line[task_id^="_tl_"],
    .gantt_task_bar[task_id^="_tl_"],
    .gantt_grid_data .gantt_row[task_id^="_tl_"] {
        display: none !important;
        visibility: hidden !important;
        height: 0 !important;
        max-height: 0 !important;
        min-height: 0 !important;
        line-height: 0 !important;
        overflow: hidden !important;
        opacity: 0 !important;
        pointer-events: none !important;
        position: absolute !important;
        left: -9999px !important;
    }
</style>

<script>
    // ========================================================================
    // CRITICAL: Override Gantt's date calculation functions FIRST
    // This must run before ANY lightbox or form configuration
    // ========================================================================
    (function() {
        const originalCalculateEndDate = gantt.calculateEndDate;
        gantt.calculateEndDate = function(start, duration, unit) {
            // CRITICAL: Check if start is an object with a start_date property
            // This happens when time control passes config object instead of Date
            if (start && typeof start === 'object' && !(start instanceof Date)) {
                if (start.start_date && start.start_date instanceof Date) {
                    console.warn('calculateEndDate: Received object with start_date property, extracting Date');
                    start = start.start_date;
                } else {
                    console.warn('calculateEndDate called with invalid object:', start, '- using fallback');
                    return new Date();
                }
            }

            // Validate inputs before calling original function
            if (!start || !(start instanceof Date) || isNaN(start.getTime())) {
                console.warn('calculateEndDate called with invalid start date:', start, '- using fallback');
                return new Date(); // Return current date as fallback
            }
            if (!duration || typeof duration !== 'number' || duration <= 0 || isNaN(duration)) {
                console.warn('calculateEndDate called with invalid duration:', duration, '- defaulting to 1');
                duration = 1; // Default to 1 day
            }
            try {
                return originalCalculateEndDate.call(this, start, duration, unit);
            } catch (e) {
                console.error('Error in calculateEndDate:', e);
                return gantt.date.add(start, duration || 1, unit || "day");
            }
        };

        const originalCalculateDuration = gantt.calculateDuration;
        gantt.calculateDuration = function(start, end, unit) {
            // Validate inputs before calling original function
            if (!start || !(start instanceof Date) || isNaN(start.getTime())) {
                console.warn('calculateDuration called with invalid start date:', start, '- using fallback');
                return 1; // Return 1 day as fallback
            }
            if (!end || !(end instanceof Date) || isNaN(end.getTime())) {
                console.warn('calculateDuration called with invalid end date:', end, '- using fallback');
                return 1; // Return 1 day as fallback
            }
            try {
                const result = originalCalculateDuration.call(this, start, end, unit);
                // Ensure result is always positive
                return (result && result > 0) ? result : 1;
            } catch (e) {
                console.error('Error in calculateDuration:', e);
                return 1;
            }
        };
        console.log('Date calculation overrides installed successfully');
    })();

    // ========================================================================
    // CRITICAL: Validate and fix task data during loading/parsing
    // This runs BEFORE Gantt processes each task internally
    // ========================================================================
    gantt.attachEvent("onTaskLoading", function(task) {
        try {
            console.log('Loading task:', task.id, 'start_date:', task.start_date, 'type:', typeof task.start_date, 'duration:', task.duration);

            // Fix start_date if missing or invalid
            if (!task.start_date || task.start_date === null || task.start_date === '' || task.start_date === 'null') {
                console.warn('Task', task.id, 'has null/empty start_date, setting to today');
                task.start_date = new Date();
            } else if (typeof task.start_date === 'number') {
                // If it's a number (like 1), it's invalid - set to today
                console.warn('Task', task.id, 'has NUMERIC start_date:', task.start_date, '- setting to today');
                task.start_date = new Date();
            } else if (typeof task.start_date === 'string') {
                // Parse string dates
                try {
                    const parsed = gantt.date.parseDate(task.start_date, "xml_date");
                    if (!parsed || isNaN(parsed.getTime())) {
                        console.warn('Task', task.id, 'has unparseable start_date:', task.start_date);
                        task.start_date = new Date();
                    } else {
                        task.start_date = parsed;
                    }
                } catch (e) {
                    console.error('Error parsing start_date for task', task.id, ':', e);
                    task.start_date = new Date();
                }
            } else if (!(task.start_date instanceof Date) || isNaN(task.start_date.getTime())) {
                console.warn('Task', task.id, 'has invalid Date object for start_date');
                task.start_date = new Date();
            }

            // Fix duration if missing or invalid
            if (!task.duration || typeof task.duration !== 'number' || task.duration <= 0 || isNaN(task.duration)) {
                console.warn('Task', task.id, 'has invalid duration:', task.duration, '- defaulting to 1');
                task.duration = 1;
            }

            // Calculate end_date if missing
            if (!task.end_date) {
                try {
                    task.end_date = gantt.calculateEndDate(task.start_date, task.duration);
                    console.log('Calculated end_date for task', task.id, ':', task.end_date);
                } catch (e) {
                    console.error('Error calculating end_date for task', task.id, ':', e);
                    task.end_date = gantt.date.add(task.start_date, 1, "day");
                }
            }

            // Ensure progress is valid
            if (!task.progress || typeof task.progress !== 'number' || task.progress < 0 || task.progress > 1) {
                task.progress = 0;
            }

            console.log('Task', task.id, 'validated - start:', task.start_date, 'duration:', task.duration, 'end:', task.end_date);
        } catch (error) {
            console.error('CRITICAL ERROR in onTaskLoading for task', task.id, ':', error);
            // Set safe defaults to prevent crash
            task.start_date = new Date();
            task.duration = 1;
            task.end_date = gantt.date.add(new Date(), 1, "day");
            task.progress = 0;
        }
        return true; // Always return true to allow task to be loaded
    });

    // Initialize Gantt Chart
    gantt.config.date_format = "%Y-%m-%d";
    gantt.config.xml_date = "%Y-%m-%d";
    gantt.config.scale_unit = "month";
    gantt.config.date_scale = "%F %Y";
    gantt.config.subscales = [
        {unit: "week", step: 1, date: "Week #%W"}
    ];
    gantt.config.min_column_width = 80;
    gantt.config.scale_height = 90;
    gantt.config.row_height = 50;  // Increased for bilingual text
    gantt.config.grid_width = 605;  // Fixed grid width
    gantt.config.autosize = false;  // Disable auto-sizing
    gantt.config.fit_tasks = false;  // Don't auto-fit timeline to tasks - use explicit date range
    gantt.config.readonly = {% if not can_edit %}true{% else %}false{% endif %};
    gantt.config.scroll_size = 17;  // Scrollbar width
    gantt.config.scrollable = true;  // Enable scrolling
    gantt.config.show_chart = true;  // Ensure timeline chart is shown
    gantt.config.show_grid = true;   // Ensure grid is shown

    // CRITICAL: Override DHTMLX's automatic date range calculation
    // Force the timeline to always show Jan 1 - Dec 31, 2025 (extended to Jan 7, 2026)
    gantt.config.start_date = new Date(2025, 0, 1);
    gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59); // Extend to Jan 7, 2026

    console.log('CONFIG: Set fixed date range:', gantt.config.start_date, 'to', gantt.config.end_date);

    // CRITICAL: Since getScale() is not called in modern DHTMLX Gantt, we need to use events
    // The onBeforeDataRender event fires before each render and allows us to force the date range
    gantt.attachEvent("onBeforeDataRender", function() {
        const fixedStart = new Date(2025, 0, 1);
        const fixedEnd = new Date(2026, 0, 7, 23, 59, 59);

        // Force the config every single time before render
        if (!gantt.config.start_date || gantt.config.start_date.getTime() !== fixedStart.getTime()) {
            console.log('onBeforeDataRender: Forcing start_date to Jan 1, 2025');
            gantt.config.start_date = fixedStart;
        }
        if (!gantt.config.end_date || gantt.config.end_date.getTime() !== fixedEnd.getTime()) {
            console.log('onBeforeDataRender: Forcing end_date to Dec 31, 2025 (extended to Jan 7, 2026)');
            gantt.config.end_date = fixedEnd;
        }
        if (gantt.config.fit_tasks !== false) {
            console.log('onBeforeDataRender: Forcing fit_tasks = false');
            gantt.config.fit_tasks = false;
        }

        return true;
    });

    // Also use onGanttRender to enforce after render
    gantt.attachEvent("onGanttRender", function() {
        const fixedStart = new Date(2025, 0, 1);
        const fixedEnd = new Date(2026, 0, 7, 23, 59, 59);

        // Verify config is still correct after render
        if (!gantt.config.start_date || gantt.config.start_date.getTime() !== fixedStart.getTime()) {
            console.warn('onGanttRender: start_date was modified during render, will fix on next render');
        }
        if (!gantt.config.end_date || gantt.config.end_date.getTime() !== fixedEnd.getTime()) {
            console.warn('onGanttRender: end_date was modified during render, will fix on next render');
        }

        return true;
    });

    console.log('✓ Date range enforcement events installed (onBeforeDataRender, onGanttRender)');

    // NUCLEAR OPTION: Override DHTMLX's internal date range calculation
    // Explore what methods are available for overriding
    console.log('Exploring gantt internals...');
    console.log('gantt._scale_helpers:', typeof gantt._scale_helpers);
    console.log('gantt.getSubtaskDates:', typeof gantt.getSubtaskDates);
    console.log('gantt.getSubtaskDuration:', typeof gantt.getSubtaskDuration);
    console.log('gantt._get_scales:', typeof gantt._get_scales);
    console.log('gantt._init_tasks_range:', typeof gantt._init_tasks_range);

    // Try multiple override strategies
    let overrideSuccess = false;

    // Strategy 1: Override getSubtaskDates (calculates date range from tasks)
    if (typeof gantt.getSubtaskDates === 'function') {
        const originalGetSubtaskDates = gantt.getSubtaskDates;
        gantt.getSubtaskDates = function() {
            // Return our fixed date range instead of calculating from tasks
            const fixedStart = new Date(2025, 0, 1);
            const fixedEnd = new Date(2026, 0, 7, 23, 59, 59);

            console.log('✓ getSubtaskDates override ACTIVE - returning fixed range');

            return {
                start_date: fixedStart,
                end_date: fixedEnd
            };
        };
        console.log('✓ gantt.getSubtaskDates overridden');
        overrideSuccess = true;
    }

    // Strategy 2: Override _init_tasks_range (initializes task date range)
    if (typeof gantt._init_tasks_range === 'function') {
        const original_init_tasks_range = gantt._init_tasks_range;
        gantt._init_tasks_range = function() {
            const result = original_init_tasks_range.apply(this, arguments);

            // Force our date range
            const fixedStart = new Date(2025, 0, 1);
            const fixedEnd = new Date(2026, 0, 7, 23, 59, 59);

            this._min_date = fixedStart;
            this._max_date = fixedEnd;

            console.log('✓ _init_tasks_range override ACTIVE - forcing _min_date and _max_date');

            return result;
        };
        console.log('✓ gantt._init_tasks_range overridden');
        overrideSuccess = true;
    }

    if (!overrideSuccess) {
        console.error('✗ Could not find any methods to override for date range control');
    }

    // ROBUST TIMELINE EXTENSION SOLUTION - Fixed dates for full year 2025
    if (gantt.ext && gantt.ext.zoom) {
        console.log('✓ gantt.ext.zoom is available - configuring zoom levels with FORCED date range');

        // Force timeline configuration BEFORE zoom init
        gantt.config.start_date = new Date(2025, 0, 1);
        gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59); // Extend to Jan 7, 2026
        gantt.config.fit_tasks = false;
        gantt.config.show_chart = true;

        gantt.ext.zoom.init({
            levels: [
                {
                    name: "day",
                    scale_height: 90,
                    min_column_width: 40,
                    scales: [
                        {unit: "day", step: 1, format: "%d %M"},
                        {unit: "hour", step: 6, format: "%H"}
                    ],
                    // CRITICAL: Explicitly set date range for day view
                    start_date: new Date(2025, 0, 1),
                    end_date: new Date(2026, 0, 7, 23, 59, 59),
                    // Force date range for day view
                    render: function(level) {
                        gantt.config.start_date = new Date(2025, 0, 1);
                        gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59);
                        gantt.config.fit_tasks = false;
                        // Force immediate render with dates
                        gantt.render();
                    }
                },
                {
                    name: "week",
                    scale_height: 90,
                    min_column_width: 60,
                    scales: [
                        {unit: "week", step: 1, format: "Week #%W"},
                        {unit: "day", step: 1, format: "%d %M"}
                    ],
                    // CRITICAL: Explicitly set date range for week view
                    start_date: new Date(2025, 0, 1),
                    end_date: new Date(2026, 0, 7, 23, 59, 59),
                    // Force date range for week view
                    render: function(level) {
                        gantt.config.start_date = new Date(2025, 0, 1);
                        gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59);
                        gantt.config.fit_tasks = false;
                        // Force immediate render with dates
                        gantt.render();
                    }
                },
                {
                    name: "month",
                    scale_height: 90,
                    min_column_width: 80,
                    scales: [
                        {unit: "month", step: 1, format: "%F %Y"},
                        {unit: "week", step: 1, format: "Week #%W"}
                    ]
                },
                {
                    name: "year",
                    scale_height: 90,
                    min_column_width: 100,
                    scales: [
                        {unit: "year", step: 1, format: "%Y"},
                        {unit: "month", step: 1, format: "%M"}
                    ]
                }
            ]
        });

        // Override zoom's setLevel - but only for Month and Year views
        // Day and Week views will bypass zoom entirely
        const originalSetLevel = gantt.ext.zoom.setLevel;
        gantt.ext.zoom.setLevel = function(level) {
            console.log('Zoom level changing to:', level);

            // For Month and Year, use normal zoom with forced dates
            if (level === 'month' || level === 'year') {
                // Force config
                gantt.config.start_date = new Date(2025, 0, 1);
                gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59);
                gantt.config.fit_tasks = false;
                gantt.config.show_chart = true;

                // Call original
                originalSetLevel.call(this, level);

            } else if (level === 'day' || level === 'week') {
                // Day and Week views should not use zoom extension
                console.log('WARNING: Zoom extension called for', level, '- this should be bypassed');

                // If somehow we get here, configure manually
                gantt.clearAll();

                gantt.config.start_date = new Date(2025, 0, 1);
                gantt.config.end_date = new Date(2026, 0, 15, 23, 59, 59);
                gantt.config.fit_tasks = false;

                if (level === 'day') {
                    gantt.config.scale_unit = "day";
                    gantt.config.date_scale = "%d %M %Y";
                    gantt.config.subscales = [{unit: "hour", step: 6, date: "%H:00"}];
                    gantt.config.min_column_width = 50;
                } else {
                    gantt.config.scale_unit = "week";
                    gantt.config.date_scale = "Week #%W of %Y";
                    gantt.config.subscales = [{unit: "day", step: 1, date: "%d %M"}];
                    gantt.config.min_column_width = 70;
                }

                gantt.parse(ganttData);
                if (typeof forceTimelineExtension === 'function') {
                    forceTimelineExtension();
                }
                gantt.render();

                // Step 5: CRITICAL - Clear all and re-parse to force timeline extension
                setTimeout(function() {
                    console.log('Refreshing Gantt data for', level, 'view...');

                    // Clear everything
                    gantt.clearAll();

                    // Re-set configuration - extend to Jan 2026
                    gantt.config.start_date = new Date(2025, 0, 1);
                    gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59); // Jan 7, 2026
                    gantt.config.fit_tasks = false;

                    // Re-parse the original data
                    gantt.parse(ganttData);

                    // Force timeline extension function
                    if (typeof forceTimelineExtension === 'function') {
                        forceTimelineExtension();
                    }

                    console.log('Data refreshed, timeline should now extend to Dec 31, 2025 (extended to Jan 7, 2026)');
                }, 100);

                // Step 3: Force multiple renders with progressive scrolling
                setTimeout(function() {
                    // Re-enforce config after zoom change
                    gantt.config.start_date = new Date(2025, 0, 1);
                    gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59); // Extend to Jan 7, 2026
                    gantt.config.fit_tasks = false;

                    // First render
                    gantt.render();

                    // Progressive scrolling to force all columns to generate
                    const scrollPositions = [
                        new Date(2025, 11, 31),  // December 31
                        new Date(2025, 10, 15),  // November 15
                        new Date(2025, 9, 15),   // October 15
                        new Date(2025, 8, 15),   // September 15
                        new Date(2025, 7, 15),   // August 15
                        new Date(2025, 6, 15),   // July 15
                        new Date(2025, 5, 15),   // June 15
                        new Date(2025, 4, 15),   // May 15
                        new Date(2025, 3, 15),   // April 15
                        new Date(2025, 2, 15),   // March 15
                        new Date(2025, 1, 15),   // February 15
                        new Date(2025, 0, 1)     // January 1
                    ];

                    let scrollIndex = 0;
                    const scrollInterval = setInterval(function() {
                        if (scrollIndex < scrollPositions.length) {
                            gantt.showDate(scrollPositions[scrollIndex]);
                            console.log('Scrolling to:', scrollPositions[scrollIndex].toDateString());
                            scrollIndex++;
                        } else {
                            clearInterval(scrollInterval);
                            // Final scroll to first task or current date
                            const firstTask = gantt.getTaskByIndex(0);
                            if (firstTask && firstTask.start_date) {
                                gantt.showTask(firstTask.id);
                            } else {
                                gantt.showDate(new Date());
                            }
                            console.log('✓ Aggressive timeline extension completed for', level, 'view');
                        }
                    }, 50);  // Fast scrolling through all months
                }, 200);

            } else {
                // For month and year views, use standard approach
                originalSetLevel.call(this, level);

                setTimeout(function() {
                    gantt.config.start_date = new Date(2025, 0, 1);
                    gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59); // Extend to Jan 7, 2026
                    gantt.config.fit_tasks = false;

                    gantt.render();

                    // Simple scroll for month/year views
                    gantt.showDate(new Date(2025, 11, 31));
                    setTimeout(function() {
                        const firstTask = gantt.getTaskByIndex(0);
                        if (firstTask) {
                            gantt.showTask(firstTask.id);
                        }
                    }, 100);

                    console.log('✓ Timeline forced to Jan 1 - Dec 31, 2025 (extended to Jan 7, 2026) for', level, 'view');
                }, 100);
            }
        };

        // CRITICAL: Attach multiple events to force dates
        gantt.attachEvent("onBeforeGanttRender", function() {
            gantt.config.start_date = new Date(2025, 0, 1);
            gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59); // Extend to Jan 7, 2026
            gantt.config.fit_tasks = false;
            console.log('onBeforeGanttRender: Enforcing full year 2025 range');
            return true;
        });

        gantt.attachEvent("onGanttReady", function() {
            gantt.config.start_date = new Date(2025, 0, 1);
            gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59); // Extend to Jan 7, 2026
            gantt.config.fit_tasks = false;
            console.log('onGanttReady: Enforcing full year 2025 range');
        });

        // Override zoom extension's internal methods to force our dates
        const originalGetScaleConfig = gantt.ext.zoom._getScaleConfig || function() {};
        if (gantt.ext.zoom._getScaleConfig) {
            gantt.ext.zoom._getScaleConfig = function(level) {
                const config = originalGetScaleConfig.call(this, level);
                // Force our date range regardless of what zoom calculates
                config.date_scale_start = new Date(2025, 0, 1);
                config.date_scale_end = new Date(2026, 0, 7, 23, 59, 59);
                return config;
            };
        }

        // Set to month view by default
        gantt.ext.zoom.setLevel("month");
        console.log('✓ Zoom extension configured with FORCED date ranges for all levels');
    } else {
        console.warn('✗ gantt.ext.zoom not available');
    }

    // Use default layout to ensure scale header displays properly
    // Custom layouts can sometimes hide the scale header

    // Enable features
    gantt.config.drag_links = true;
    gantt.config.drag_progress = {% if can_edit %}true{% else %}false{% endif %};
    gantt.config.drag_resize = {% if can_edit %}true{% else %}false{% endif %};
    gantt.config.drag_move = {% if can_edit %}true{% else %}false{% endif %};
    gantt.config.show_progress = true;
    gantt.config.order_branch = true;
    gantt.config.order_branch_free = true;  // Allow reordering within branches
    gantt.config.auto_scheduling = false;
    gantt.config.highlight_critical_path = {{ show_critical_path|lower }};

    // Allow editing of past tasks - override DHTMLX Gantt's default behavior
    // By default, DHTMLX Gantt prevents editing tasks whose end_date is in the past
    // This function returns false to allow editing all tasks regardless of their dates
    gantt.config.readonly_form = function(task) {
        // Return false to make ALL tasks editable
        // Return true would make a task read-only
        return false;
    };

    // Configure drag behavior to maintain hierarchy level
    gantt.config.round_dnd_dates = false;
    gantt.config.details_on_dblclick = true;

    // Enable row reordering via drag and drop
    gantt.config.reorder_grid_columns = false;  // Disable column reorder

    // Enable keyboard navigation and deletion
    gantt.config.keyboard_navigation = true;
    gantt.config.keyboard_navigation_cells = true;

    // Custom keyboard shortcuts
    gantt.keys.edit_save = 13;  // Enter to save
    gantt.keys.edit_cancel = 27;  // Esc to cancel

    gantt.ext.inlineEditors.attachEvent("onBeforeEditStart", function(state) {
        return gantt.config.readonly ? false : true;
    });

    // Helper function to escape HTML
    function escapeHtml(text) {
        const map = {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#039;'
        };
        return text.replace(/[&<>"']/g, function(m) { return map[m]; });
    }

    // Grid columns - optimized widths with Chinese text support
    gantt.config.columns = [
        {
            name: "text",
            label: "Task name",
            tree: true,
            width: 280,
            resize: true,
            template: function(task) {
                // Filter out timeline forcing tasks
                if (task.id && task.id.toString().startsWith('_tl_')) {
                    return '';
                }
                // Show both English and Chinese if available
                console.log('Rendering task:', task.id, 'title_cn:', task.title_cn); // Debug
                if (task.title_cn && task.title_cn.trim() !== '') {
                    return '<div style="line-height: 1.4; padding: 2px 0;">' +
                           '<div style="font-weight: 500;">' + escapeHtml(task.text) + '</div>' +
                           '<div style="color: #0066cc; font-size: 0.85em; margin-top: 2px;">' + escapeHtml(task.title_cn) + '</div>' +
                           '</div>';
                }
                return '<div style="padding: 2px 0; font-weight: 500;">' + escapeHtml(task.text) + '</div>';
            }
        },
        {name: "task_code", label: "Code", width: 90, align: "center", resize: true},
        {name: "start_date", label: "Start", width: 90, align: "center", resize: true},
        {name: "duration", label: "Days", width: 55, align: "center", resize: true},
        {
            name: "progress",
            label: "%",
            width: 55,
            align: "center",
            resize: true,
            template: function(task) {
                return Math.round(task.progress * 100) + "%";
            }
        },
        {name: "add", label: "", width: 35}
    ];

    // ========================================================================
    // CUSTOM DURATION FORM BLOCK - FIX FOR DATE HANDLING
    // ========================================================================
    // Override the built-in duration control to ensure dates are always Date objects
    // This fixes the "k.getDate is not a function" error
    // IMPORTANT: This must be defined BEFORE the lightbox configuration
    (function() {
        // Store the original duration form block
        const originalDuration = gantt.form_blocks["duration"];

        if (originalDuration) {
            // Create a wrapper that validates dates before calling the original
            gantt.form_blocks["duration"] = {
                render: originalDuration.render,

                set_value: function(node, value, task, section) {
                    console.log('Duration control set_value called with:', { value, task_id: task.id, task });

                    // CRITICAL FIX: The duration control uses the 'value' parameter, not just task
                    // We need to ensure both value.start_date and task.start_date are valid Date objects

                    // Fix value.start_date if it exists and is invalid
                    if (value && typeof value === 'object') {
                        if (value.start_date !== undefined && !(value.start_date instanceof Date)) {
                            console.warn('Duration control: value.start_date is', typeof value.start_date, '- converting to Date');
                            if (typeof value.start_date === 'string') {
                                value.start_date = gantt.date.parseDate(value.start_date, "xml_date") || new Date();
                            } else if (typeof value.start_date === 'number') {
                                // If it's a number like 1, it's definitely wrong - use task's actual start_date
                                value.start_date = task.start_date instanceof Date ? task.start_date : new Date();
                            } else {
                                value.start_date = new Date();
                            }
                        }

                        if (value.end_date !== undefined && !(value.end_date instanceof Date)) {
                            console.warn('Duration control: value.end_date is', typeof value.end_date, '- converting to Date');
                            if (typeof value.end_date === 'string') {
                                value.end_date = gantt.date.parseDate(value.end_date, "xml_date") || new Date();
                            } else {
                                value.end_date = task.end_date instanceof Date ? task.end_date : new Date();
                            }
                        }
                    }

                    // Also fix task.start_date
                    if (task.start_date && !(task.start_date instanceof Date)) {
                        console.warn('Duration control: task.start_date is', typeof task.start_date, '- converting to Date');
                        try {
                            if (typeof task.start_date === 'string') {
                                task.start_date = gantt.date.parseDate(task.start_date, "xml_date") || new Date();
                            } else {
                                task.start_date = new Date();
                            }
                        } catch (e) {
                            console.error('Duration control: Error converting start_date:', e);
                            task.start_date = new Date();
                        }
                    } else if (!task.start_date || isNaN(task.start_date.getTime())) {
                        console.warn('Duration control: Invalid start_date, setting to today');
                        task.start_date = new Date();
                    }

                    // Also ensure end_date is a valid Date object
                    if (task.end_date && !(task.end_date instanceof Date)) {
                        console.warn('Duration control: Converting end_date from', typeof task.end_date, 'to Date');
                        try {
                            if (typeof task.end_date === 'string') {
                                task.end_date = gantt.date.parseDate(task.end_date, "xml_date") || gantt.date.add(task.start_date, 1, "day");
                            } else {
                                task.end_date = gantt.date.add(task.start_date, 1, "day");
                            }
                        } catch (e) {
                            console.error('Duration control: Error converting end_date:', e);
                            task.end_date = gantt.date.add(task.start_date, 1, "day");
                        }
                    } else if (!task.end_date || isNaN(task.end_date.getTime())) {
                        console.warn('Duration control: Invalid end_date, calculating from start_date');
                        task.end_date = gantt.date.add(task.start_date, task.duration || 1, "day");
                    }

                    // Ensure duration is a valid number
                    if (!task.duration || typeof task.duration !== 'number' || task.duration <= 0 || isNaN(task.duration)) {
                        console.warn('Duration control: Invalid duration, calculating from dates');
                        task.duration = gantt.calculateDuration(task.start_date, task.end_date) || 1;
                    }

                    // Add logging to debug what we're passing
                    console.log('Duration control set_value - About to call original with:', {
                        start_date: task.start_date,
                        end_date: task.end_date,
                        duration: task.duration,
                        start_is_date: task.start_date instanceof Date,
                        end_is_date: task.end_date instanceof Date
                    });

                    // Now call the original set_value with validated data
                    // Wrap in try-catch to handle any internal errors
                    try {
                        return originalDuration.set_value.call(this, node, value, task, section);
                    } catch (e) {
                        console.error('Duration control: Error in original set_value:', e);
                        console.error('Task data was:', task);

                        // Fallback: manually set the duration display
                        if (node && node.querySelector) {
                            const durationInput = node.querySelector('input[type="text"]');
                            if (durationInput) {
                                durationInput.value = task.duration || 1;
                            }
                        }

                        // Return without error to prevent crash
                        return;
                    }
                },

                get_value: originalDuration.get_value,
                focus: originalDuration.focus
            };

            console.log('Custom duration form block installed successfully');
        } else {
            console.warn('Original duration form block not found - cannot override');
        }
    })();

    // ========================================================================
    // CUSTOM DATE FORM BLOCK - COMMENTED OUT (was interfering with time controls)
    // ========================================================================
    // Note: We use type: "time" instead of type: "date" for date fields
    // The time control handles date validation internally, so no custom override needed

    // Configure Lightbox (Task Edit Dialog)
    gantt.config.lightbox.sections = [
        {name: "description", height: 38, map_to: "text", type: "textarea", focus: true},
        {name: "chinese_title", height: 38, map_to: "title_cn", type: "textarea", focus: false},
        {name: "process_owner", height: 38, map_to: "process_owner_id", type: "select", options: [
            {key: '', label: 'No owner'},
            {% for member in project.team_members.all %}
            {key: '{{ member.pk }}', label: '{{ member.get_full_name|default:member.email|escapejs }}'},
            {% endfor %}
        ]},
        {name: "definition_of_done", height: 70, map_to: "definition_of_done", type: "textarea", focus: false},
        {name: "predecessors", height: 350, map_to: "auto", type: "template", focus: false},
        {name: "time", height: 72, map_to: "auto", type: "time", time_format: ["%Y", "%m", "%d"]},
        {name: "duration", height: 38, map_to: "duration", type: "textarea", focus: false}
    ];

    // Custom labels for lightbox sections
    gantt.locale.labels.section_description = "Task Title (English)";
    gantt.locale.labels.section_chinese_title = "Task Title (中文)";
    gantt.locale.labels.section_process_owner = "Process Owner";
    gantt.locale.labels.section_definition_of_done = "Definition of Done (DoD)";
    gantt.locale.labels.section_predecessors = "Dependencies / Predecessors";
    gantt.locale.labels.section_time = "Task Dates";
    gantt.locale.labels.section_duration = "Duration (days)";

    // ========================================================================
    // CUSTOM PREDECESSORS/DEPENDENCIES SECTION
    // ========================================================================

    // Initialize template form block if it doesn't exist
    if (!gantt.form_blocks["template"]) {
        gantt.form_blocks["template"] = {
            render: function(sns) {
                // IMPORTANT: This MUST return an HTML STRING, not a DOM element
                // dhtmlxGantt will convert the string to DOM internally
                return "<div class='gantt_cal_ltext'></div>";
            },
            set_value: function(node, value, task, section) {
                // node is the DOM element created from the HTML string returned by render
            },
            get_value: function(node, task, section) {
                return "";
            },
            focus: function(node) {}
        };
    }

    // Store original template handlers
    const originalTemplateRender = gantt.form_blocks["template"].render;
    const originalTemplateSetValue = gantt.form_blocks["template"].set_value;
    const originalTemplateGetValue = gantt.form_blocks["template"].get_value;
    const originalTemplateFocus = gantt.form_blocks["template"].focus;

    // Template function to render the predecessors UI
    gantt.form_blocks["template"].render = function(sns) {
        try {
            console.log('Template render called for:', sns.name, 'type:', sns.type);

            if (sns.name === "predecessors") {
                console.log('Rendering predecessors section...');

                // IMPORTANT: Return just the INNER HTML without the gantt_cal_ltext wrapper
                // dhtmlxGantt will add the wrapper itself
                const html = `<div id="predecessors_list" style="margin-bottom: 10px;"></div>
<div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd;">
    <div style="margin-bottom: 8px;">
        <label style="display: block; margin-bottom: 4px; font-weight: 500; font-size: 12px;">Select Predecessor Task:</label>
        <select id="predecessor_select" style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 3px; font-size: 13px;">
            <option value="">-- Select Task --</option>
        </select>
    </div>
    <div style="display: flex; gap: 8px; align-items: center; margin-bottom: 8px;">
        <div style="flex: 1;">
            <label style="display: block; margin-bottom: 4px; font-weight: 500; font-size: 12px;">Dependency Type:</label>
            <select id="dependency_type_select" style="width: 100%; padding: 6px; border: 1px solid #ccc; border-radius: 3px; font-size: 13px;">
                <option value="FS">FS - Finish to Start</option>
                <option value="SS">SS - Start to Start</option>
                <option value="FF">FF - Finish to Finish</option>
                <option value="SF">SF - Start to Finish</option>
            </select>
        </div>
        <div style="padding-top: 24px;">
            <button type="button" id="add_predecessor_btn" style="padding: 8px 16px; background: #28a745; color: white; border: none; border-radius: 3px; cursor: pointer; white-space: nowrap; font-weight: 500; font-size: 13px;">
                + Add Dependency
            </button>
        </div>
    </div>
    <div style="margin-top: 5px; padding: 6px; background: #f8f9fa; border-radius: 3px; font-size: 11px; color: #666;">
        <strong>Types:</strong> FS=Finish-to-Start, SS=Start-to-Start, FF=Finish-to-Finish, SF=Start-to-Finish
    </div>
</div>`;

                console.log('Predecessors HTML generated, length:', html.length);
                return html; // Return HTML STRING without wrapper
            }
            // Call original handler for other template sections
            if (originalTemplateRender) {
                console.log('Calling original template render for:', sns.name);
                return originalTemplateRender(sns);
            }
            console.log('No handler for template section:', sns.name, '- returning empty div');
            return "<div class='gantt_cal_ltext'></div>";
        } catch (error) {
            console.error('ERROR in template render:', error);
            return "<div class='gantt_cal_ltext' style='color: red;'>Error loading section</div>";
        }
    };

    // Set value function - populate the predecessors list when opening lightbox
    gantt.form_blocks["template"].set_value = function(node, value, task, section) {
        console.log('=== set_value called for section:', section.name);
        console.log('node type:', typeof node);
        console.log('node:', node);
        console.log('node is HTMLElement:', node instanceof HTMLElement);
        console.log('node.nodeType:', node ? node.nodeType : 'undefined');

        if (section.name === "predecessors") {
            console.log('=== Setting up predecessors section for task:', task.id);
            try {
                // node is just the first element, we need to find siblings in the parent
                // Get the parent container that has all our elements
                const parentNode = node.parentNode;
                console.log('Parent node:', parentNode);

                // Find elements from the parent (they're siblings of node)
                const listContainer = parentNode.querySelector('#predecessors_list');
                const predecessorSelect = parentNode.querySelector('#predecessor_select');
                const addBtn = parentNode.querySelector('#add_predecessor_btn');

                console.log('listContainer:', listContainer);
                console.log('predecessorSelect:', predecessorSelect);
                console.log('addBtn:', addBtn);

                if (!listContainer || !predecessorSelect || !addBtn) {
                    console.error('Predecessors UI elements not found in parent');
                    console.log('Trying document-wide search...');
                    // Fallback: search in the whole lightbox
                    const lightbox = document.querySelector('.gantt_cal_light');
                    if (lightbox) {
                        const list2 = lightbox.querySelector('#predecessors_list');
                        const select2 = lightbox.querySelector('#predecessor_select');
                        const btn2 = lightbox.querySelector('#add_predecessor_btn');
                        if (list2 && select2 && btn2) {
                            console.log('Found elements in lightbox!');
                            // Use these instead
                            return setupPredecessors(list2, select2, btn2, task);
                        }
                    }
                    console.error('Could not find predecessors UI elements anywhere');
                    return;
                }

                // Setup the predecessors UI
                setupPredecessors(listContainer, predecessorSelect, addBtn, task);

            } catch (error) {
                console.error('Error in predecessors section:', error);
                // Show error message in the UI
                if (node && node.parentNode) {
                    const errorDiv = document.createElement('div');
                    errorDiv.style.cssText = 'color: red; padding: 10px;';
                    errorDiv.textContent = 'Error loading predecessors. Check console for details.';
                    node.parentNode.appendChild(errorDiv);
                }
            }
        } else {
            console.log('Not predecessors section, checking for original handler...');
            if (originalTemplateSetValue) {
                console.log('Calling original set_value handler');
                try {
                    originalTemplateSetValue(node, value, task, section);
                } catch (error) {
                    console.error('Error in original set_value:', error);
                }
            } else {
                console.log('No original set_value handler');
            }
        }
    };

    // Helper function to setup predecessors UI
    function setupPredecessors(listContainer, predecessorSelect, addBtn, task) {
        console.log('Setting up predecessors UI for task:', task.id);

        // Get parent node to find other elements
        const parentNode = listContainer.parentNode;
        const depTypeSelect = parentNode.querySelector('#dependency_type_select');

        // Check if taskB is a descendant of taskA (with depth limit to prevent infinite loops)
        function isDescendant(taskId, ancestorId, depth = 0) {
            if (depth > 20) return false; // Safety limit
            try {
                const t = gantt.getTask(taskId);
                if (!t) return false;
                if (t.parent === ancestorId) return true;
                if (t.parent && t.parent !== 0 && t.parent !== gantt.config.root_id) {
                    return isDescendant(t.parent, ancestorId, depth + 1);
                }
                return false;
            } catch (e) {
                console.error('Error in isDescendant:', e);
                return false;
            }
        }

        // Populate task dropdown (exclude current task and its descendants)
        function populateTaskDropdown(currentTaskId) {
            predecessorSelect.innerHTML = '<option value="">-- Select Task --</option>';

            try {
                gantt.eachTask(function(t) {
                    // Exclude current task and its descendants
                    if (t.id !== currentTaskId && !isDescendant(t.id, currentTaskId)) {
                        const option = document.createElement('option');
                        option.value = t.id;
                        option.textContent = `${t.task_code || t.id} - ${t.text}`;
                        predecessorSelect.appendChild(option);
                    }
                });
            } catch (e) {
                console.error('Error populating task dropdown:', e);
            }
        }

        // Display current predecessors
        function displayPredecessors() {
            const predecessorLinks = gantt.getLinks().filter(link => link.target == task.id);

            if (predecessorLinks.length === 0) {
                listContainer.innerHTML = '<div style="color: #999; font-style: italic; padding: 5px;">No predecessors defined</div>';
            } else {
                let html = '<div style="font-weight: 500; margin-bottom: 5px; color: #333;">Current Predecessors:</div>';
                predecessorLinks.forEach(link => {
                    const predTask = gantt.getTask(link.source);
                    const typeMap = {0: 'FS', 1: 'SS', 2: 'FF', 3: 'SF'};
                    const depType = typeMap[link.type] || 'FS';

                    html += `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 6px; margin-bottom: 4px; background: white; border: 1px solid #ddd; border-radius: 3px;">
                            <span style="flex: 1;">
                                <strong>${predTask.task_code || predTask.id}</strong>: ${predTask.text}
                                <span style="color: #666; font-size: 11px; margin-left: 8px;">[${depType}]</span>
                            </span>
                            <button type="button" class="remove_predecessor_btn" data-link-id="${link.id}"
                                style="padding: 3px 8px; background: #dc3545; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;">
                                Remove
                            </button>
                        </div>
                    `;
                });
                listContainer.innerHTML = html;

                // Attach remove handlers
                parentNode.querySelectorAll('.remove_predecessor_btn').forEach(btn => {
                    btn.onclick = function(e) {
                        e.preventDefault();
                        const linkId = this.getAttribute('data-link-id');

                        if (confirm('Remove this dependency?')) {
                            // Remove from Gantt
                            gantt.deleteLink(linkId);
                            displayPredecessors();
                        }
                    };
                });
            }
        }

        // Add predecessor button handler
        addBtn.onclick = function(e) {
            console.log('%c=== ADD PREDECESSOR BUTTON CLICKED ===', 'color: blue; font-weight: bold;');
            e.preventDefault();
            const predecessorId = predecessorSelect.value;
            const depType = depTypeSelect ? depTypeSelect.value : 'FS';

            console.log('Selected predecessor ID:', predecessorId);
            console.log('Selected dependency type:', depType);
            console.log('Target task ID:', task.id);

            if (!predecessorId) {
                console.warn('No predecessor selected');
                alert('Please select a task');
                return;
            }

            // Check if dependency already exists
            const existingLink = gantt.getLinks().find(link =>
                link.source == predecessorId && link.target == task.id
            );

            if (existingLink) {
                console.warn('Dependency already exists:', existingLink);
                alert('This dependency already exists');
                return;
            }

            // Map dependency type to Gantt link type
            const typeMap = {FS: "0", SS: "1", FF: "2", SF: "3"};
            const linkType = typeMap[depType];

            console.log('Creating link with type:', linkType);
            console.log('Link data:', {
                source: predecessorId,
                target: task.id,
                type: linkType
            });

            // Add link to Gantt (this will trigger onAfterLinkAdd event)
            const linkId = gantt.addLink({
                source: predecessorId,
                target: task.id,
                type: linkType
            });

            console.log('Link created with ID:', linkId);

            if (linkId) {
                console.log('Refreshing predecessors display...');
                displayPredecessors();
                predecessorSelect.value = '';
            } else {
                console.error('Failed to create link - linkId is:', linkId);
            }
        };

        // Initialize the UI
        populateTaskDropdown(task.id);
        displayPredecessors();
    }

    // Get value function - not needed for template type, but required
    gantt.form_blocks["template"].get_value = function(node, task, section) {
        if (section.name === "predecessors") {
            return ""; // Predecessors section doesn't store a value
        }
        if (originalTemplateGetValue) {
            return originalTemplateGetValue(node, task, section);
        }
        return task[section.map_to] || "";
    };

    // Focus function - optional
    gantt.form_blocks["template"].focus = function(node) {
        if (originalTemplateFocus) {
            originalTemplateFocus(node);
        }
    };

    // Debug double-click events
    gantt.attachEvent("onTaskDblClick", function(id, e){
        console.log('=== DOUBLE CLICK DETECTED on task:', id);
        return true; // Allow default behavior
    });

    // Lightbox opened successfully
    gantt.attachEvent("onLightbox", function(task_id){
        console.log('=== Lightbox SUCCESSFULLY Opened for task:', task_id);
        console.log('Task ID:', task_id);
        const task = gantt.getTask(task_id);
        console.log('Task title (EN):', task.text);
        console.log('Task title (CN):', task.title_cn || '(empty)');
        console.log('Please enter Chinese text in the "Task Title (中文)" field if you want to add it.');

        // Set end_date if not already set (end_date = start_date + duration)
        // IMPORTANT: Validate ALL parameters before using calculateEndDate
        if (!task.end_date && task.start_date) {
            try {
                // Parse and validate start_date
                let startDate = task.start_date;
                if (!(startDate instanceof Date)) {
                    startDate = gantt.date.parseDate(task.start_date, "xml_date");
                }

                // Validate duration (must be a positive number)
                let duration = task.duration;
                if (!duration || typeof duration !== 'number' || duration <= 0 || isNaN(duration)) {
                    duration = 1; // Default to 1 day
                }

                // Only call calculateEndDate if we have valid inputs
                if (startDate && !isNaN(startDate.getTime()) && duration > 0) {
                    task.end_date = gantt.calculateEndDate(startDate, duration);
                }
            } catch (e) {
                console.warn('Could not calculate end_date in onLightbox:', e);
            }
        }

        return true;
    });

    // Auto-calculate duration when dates change in lightbox
    gantt.attachEvent("onBeforeLightbox", function(task_id){
        console.log('=== onBeforeLightbox triggered for task:', task_id);
        try {
            const task = gantt.getTask(task_id);
            console.log('Task data:', {
                id: task.id,
                text: task.text,
                start_date: task.start_date,
                end_date: task.end_date,
                duration: task.duration
            });

        // Ensure task has valid dates before opening lightbox
        // This prevents the "Invalid start_date argument for calculateEndDate" error
        if (!task.start_date || task.start_date === null || task.start_date === '') {
            // Set default start date to today if missing
            task.start_date = new Date();
            console.log('Set default start_date for task', task_id, '(was null/empty)');
        } else if (typeof task.start_date === 'number') {
            // If it's a number (like 1), it's invalid - set to today
            console.warn('Task', task_id, 'has NUMERIC start_date:', task.start_date, '- fixing to today');
            task.start_date = new Date();
        } else if (!(task.start_date instanceof Date)) {
            // Try to parse it
            console.warn('Task', task_id, 'start_date is not a Date object, type:', typeof task.start_date, '- fixing');
            task.start_date = new Date();
        } else if (isNaN(task.start_date.getTime())) {
            // It's a Date object but invalid
            console.warn('Task', task_id, 'has invalid Date object for start_date - fixing');
            task.start_date = new Date();
        }

        if (!task.end_date || task.end_date === null) {
            // Calculate end date based on duration, or default to start_date + 1 day
            try {
                // Parse and validate start_date
                let startDate = task.start_date;
                if (!(startDate instanceof Date)) {
                    startDate = gantt.date.parseDate(task.start_date, "xml_date");
                }

                // Validate duration (must be a positive number)
                let duration = task.duration;
                if (!duration || typeof duration !== 'number' || duration <= 0 || isNaN(duration)) {
                    duration = 1; // Default to 1 day
                    task.duration = 1; // Update task duration
                }

                // Only call calculateEndDate with validated parameters
                if (startDate && !isNaN(startDate.getTime()) && duration > 0) {
                    task.end_date = gantt.calculateEndDate(startDate, duration);
                } else {
                    // Fallback: set end_date = start_date + 1 day
                    task.end_date = gantt.date.add(task.start_date || new Date(), 1, "day");
                }
            } catch (e) {
                console.warn('Could not calculate end_date in onBeforeLightbox, using default:', e);
                task.end_date = gantt.date.add(task.start_date || new Date(), 1, "day");
            }
        }

        // Calculate duration if not set or invalid
        if ((!task.duration || task.duration <= 0) && task.start_date && task.end_date) {
            try {
                // Parse dates if needed
                let startDate = task.start_date instanceof Date ? task.start_date : gantt.date.parseDate(task.start_date, "xml_date");
                let endDate = task.end_date instanceof Date ? task.end_date : gantt.date.parseDate(task.end_date, "xml_date");

                // Validate dates before calculating duration
                if (startDate && endDate && !isNaN(startDate.getTime()) && !isNaN(endDate.getTime())) {
                    task.duration = gantt.calculateDuration(startDate, endDate);
                    // Ensure duration is at least 1
                    if (!task.duration || task.duration <= 0) {
                        task.duration = 1;
                    }
                } else {
                    task.duration = 1; // Default fallback
                }
            } catch (e) {
                console.warn('Could not calculate duration in onBeforeLightbox:', e);
                task.duration = 1;
            }
        }

        // Final safety check: ensure duration is always a positive number
        if (!task.duration || typeof task.duration !== 'number' || task.duration <= 0 || isNaN(task.duration)) {
            task.duration = 1;
        }

        } catch (error) {
            console.error('CRITICAL ERROR in onBeforeLightbox:', error);
            // Don't prevent lightbox from opening even if there's an error
        }

        console.log('=== Returning true from onBeforeLightbox - lightbox should open ===');
        return true;
    });

    // Update duration when dates are changed and validate date range
    gantt.attachEvent("onLightboxChange", function(task_id, section, value){
        const task = gantt.getTask(task_id);

        if (section === "start_date" || section === "end_date") {
            // Recalculate duration based on dates with validation
            if (task.start_date && task.end_date) {
                try {
                    // Parse dates if needed
                    let startDate = task.start_date instanceof Date ? task.start_date : gantt.date.parseDate(task.start_date, "xml_date");
                    let endDate = task.end_date instanceof Date ? task.end_date : gantt.date.parseDate(task.end_date, "xml_date");

                    // Validate dates before calculating duration
                    if (startDate && endDate && !isNaN(startDate.getTime()) && !isNaN(endDate.getTime())) {
                        // Check if end_date is before start_date
                        if (endDate < startDate) {
                            console.warn('End date is before start date, auto-correcting...');
                            // Auto-correct: set end_date = start_date + 1 day
                            task.end_date = gantt.date.add(startDate, 1, "day");
                            endDate = task.end_date;
                            alert('Warning: End date cannot be before start date. Adjusted to start date + 1 day.');
                        }

                        const calculatedDuration = gantt.calculateDuration(startDate, endDate);
                        // Ensure duration is at least 1
                        task.duration = (calculatedDuration && calculatedDuration > 0) ? calculatedDuration : 1;
                    } else {
                        task.duration = 1;
                    }
                } catch (e) {
                    console.warn('Could not calculate duration in onLightboxChange:', e);
                    task.duration = 1;
                }
            }
        }

        return true;
    });

    // Fix lightbox positioning - center it properly
    gantt.config.lightbox_additional_height = 100;

    // Templates
    gantt.templates.task_text = function(start, end, task) {
        if (task.title_cn && task.title_cn.trim() !== '') {
            return escapeHtml(task.text) + ' <span style="color: #0099ff;">' + escapeHtml(task.title_cn) + '</span>';
        }
        return escapeHtml(task.text);
    };

    gantt.templates.rightside_text = function(start, end, task) {
        if (task.progress >= 1) {
            return "<i class='fas fa-check-circle' style='color: #198754;'></i>";
        }
        return "";
    };

    gantt.templates.task_class = function(start, end, task) {
        let classes = [];

        // Critical path highlighting
        if (task.critical) {
            classes.push("critical_task");
        }

        // Milestone
        if (task.is_milestone) {
            classes.push("milestone");
        }

        // Priority coloring
        if (task.priority) {
            classes.push("priority-" + task.priority);
        }

        return classes.join(" ");
    };

    // Prepare data for Gantt
    const ganttData = {
        data: [
            {% for task in tasks %}
            {
                id: {{ task.pk }},
                text: "{{ task.text|escapejs }}",
                title_cn: "{{ task.title_cn|default:""|escapejs }}",
                task_code: "{{ task.task_code|default:"" }}",
                start_date: {% if task.start_date %}"{{ task.start_date|date:"Y-m-d" }}"{% else %}null{% endif %},
                end_date: {% if task.end_date %}"{{ task.end_date|date:"Y-m-d" }}"{% else %}null{% endif %},
                duration: {{ task.duration|default:1 }},
                progress: {{ task.progress|default:0 }}{% if not task.is_boundary %} / 100{% endif %},
                parent: {% if task.parent_task %}{{ task.parent_task.pk }}{% else %}0{% endif %},
                priority: "{{ task.priority|default:"medium" }}",
                status: "{{ task.status|default:"pending" }}",
                is_milestone: {% if task.is_milestone %}{{ task.is_milestone|lower }}{% else %}false{% endif %},
                is_boundary: {% if task.is_boundary %}true{% else %}false{% endif %},
                critical: {% if task.id in critical_path %}true{% else %}false{% endif %},
                open: true,
                process_owner_id: {% if task.process_owner %}"{{ task.process_owner.pk }}"{% else %}""{% endif %},
                definition_of_done: "{{ task.definition_of_done|escapejs }}",
                assignees: [
                    {% for user in task.assigned_to.all %}
                    {
                        id: {{ user.pk }},
                        name: "{{ user.get_full_name|default:user.email|escapejs }}"
                    }{% if not forloop.last %},{% endif %}
                    {% endfor %}
                ]
            }{% if not forloop.last %},{% endif %}
            {% endfor %}
        ],
        links: [
            {% for task in tasks %}
            {% for dep in task.predecessors.all %}
            {
                id: {{ dep.pk }},
                source: {{ dep.predecessor.pk }},
                target: {{ dep.successor.pk }},
                type: {% if dep.dependency_type == 'FS' %}0{% elif dep.dependency_type == 'SS' %}1{% elif dep.dependency_type == 'FF' %}2{% else %}3{% endif %}
            }{% if not forloop.last or not forloop.parentloop.last %},{% endif %}
            {% endfor %}
            {% endfor %}
        ]
    };

    // ========================================================================
    // CRITICAL: Sanitize data BEFORE passing to Gantt
    // This ensures NO tasks with null/invalid dates reach Gantt's parser
    // ========================================================================
    console.log('=== Sanitizing ganttData before parsing ===');
    console.log('Total tasks:', ganttData.data.length);
    console.log('Total links:', ganttData.links.length);
    console.log('Links data:', ganttData.links);
    const today = new Date();
    ganttData.data.forEach(function(task, index) {
        // Fix null or invalid start_date
        // Check for: null, 'null', undefined, numbers, invalid dates
        let needsDefaultDate = false;

        if (!task.start_date || task.start_date === null || task.start_date === 'null' || task.start_date === undefined) {
            needsDefaultDate = true;
        } else if (typeof task.start_date === 'number') {
            // If it's a number like 1, it's invalid
            console.warn('Task', task.id, '(' + task.task_code + ') has numeric start_date:', task.start_date);
            needsDefaultDate = true;
        } else if (typeof task.start_date === 'string') {
            // Try to parse the string
            const parsed = gantt.date.parseDate(task.start_date, "%Y-%m-%d");
            if (!parsed || isNaN(parsed.getTime())) {
                console.warn('Task', task.id, '(' + task.task_code + ') has unparseable start_date:', task.start_date);
                needsDefaultDate = true;
            } else {
                task.start_date = parsed;
            }
        } else if (task.start_date instanceof Date) {
            // Check if it's a valid Date object
            if (isNaN(task.start_date.getTime())) {
                console.warn('Task', task.id, '(' + task.task_code + ') has invalid Date object');
                needsDefaultDate = true;
            }
        } else if (typeof task.start_date === 'object') {
            // It's an object but not a Date - invalid
            console.warn('Task', task.id, '(' + task.task_code + ') has object start_date:', task.start_date);
            needsDefaultDate = true;
        }

        if (needsDefaultDate) {
            console.warn('Task', task.id, '(' + task.task_code + ') - setting start_date to today');
            task.start_date = new Date(today);
        }

        // Validate and fix end_date
        if (task.end_date) {
            let validEndDate = false;

            if (typeof task.end_date === 'string') {
                const parsed = gantt.date.parseDate(task.end_date, "%Y-%m-%d");
                if (parsed && !isNaN(parsed.getTime())) {
                    task.end_date = parsed;
                    validEndDate = true;
                }
            } else if (task.end_date instanceof Date && !isNaN(task.end_date.getTime())) {
                validEndDate = true;
            }

            if (!validEndDate) {
                console.warn('Task', task.id, '(' + task.task_code + ') has invalid end_date - removing it');
                delete task.end_date;
            }
        }

        // Ensure duration is valid
        if (!task.duration || task.duration <= 0 || isNaN(task.duration)) {
            console.warn('Task', task.id, '(' + task.task_code + ') has invalid duration:', task.duration, '- setting to 1');
            task.duration = 1;
        }

        // Ensure progress is valid (0 to 1)
        if (typeof task.progress !== 'number' || task.progress < 0 || task.progress > 1 || isNaN(task.progress)) {
            task.progress = 0;
        }
    });
    console.log('=== Data sanitization complete ===');

    // WORKAROUND: Add invisible marker tasks to force timeline extension
    // This forces the timeline to extend through the entire year 2025
    console.log('=== Adding timeline marker tasks ===');

    // NOTE: After extensive testing, marker tasks cause calculateDuration errors
    // and DHTMLX Gantt still ignores the fixed date range.
    // The proper solution is to use start_date/end_date config (set above in line 820-821)
    // combined with forcing the scale to render via attachEvent

    // DO NOT add marker tasks - they cause errors and don't work as intended
    console.log('=== Skipping marker tasks - using config-based approach instead ===');


    // Removed boundary task templates - no longer needed

    // CRITICAL: Set start_date and end_date BEFORE initialization
    // Force the timeline range to include the full year 2025
    gantt.config.start_date = new Date(2025, 0, 1);
    gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59); // Extend to Jan 7, 2026
    console.log('BEFORE INIT - start_date:', gantt.config.start_date);
    console.log('BEFORE INIT - end_date:', gantt.config.end_date);
    console.log('BEFORE INIT - fit_tasks:', gantt.config.fit_tasks);

    // Removed filter - all tasks should be displayed

    // Initialize Gantt
    gantt.init("gantt_here");

    // Clear any existing data to prevent accumulation
    gantt.clearAll();

    // Parse the data
    gantt.parse(ganttData);

    console.log('=== Gantt initialized and data parsed ===');
    console.log('Total tasks loaded:', gantt.getTaskCount());

    // ALTERNATIVE SOLUTION: Create real but hidden tasks to force timeline
    console.log('=== Alternative timeline extension using real tasks ===');

    // Create actual tasks throughout the year to force timeline extension
    window.forceTimelineExtension = function() {
        const viewMode = document.querySelector('input[name="viewMode"]:checked')?.value || 'month';

        console.log('Creating timeline forcing tasks for', viewMode, 'view');

        // Remove old placeholders first
        const tasksToRemove = [];
        gantt.eachTask(function(task) {
            if (task.id && (task.id.toString().startsWith('_tl_') ||
                           task.id.toString().startsWith('_timeline_') ||
                           task.id.toString().startsWith('_month_'))) {
                tasksToRemove.push(task.id);
            }
        });

        tasksToRemove.forEach(function(id) {
            if (gantt.isTaskExists(id)) {
                gantt.silent(function() {
                    gantt.deleteTask(id);
                });
            }
        });

        if (viewMode === 'day' || viewMode === 'week') {
            // For Day/Week views, create more aggressive task distribution
            console.log('Creating aggressive timeline tasks for full year 2025 and beyond...');

            // Strategy 1: Weekly tasks throughout the year
            const startDate = new Date(2025, 0, 1);
            const endDate = new Date(2025, 11, 31);
            let currentDate = new Date(startDate);
            let taskIndex = 0;

            // Create weekly tasks
            while (currentDate <= endDate) {
                const taskId = '_tl_w_' + taskIndex;
                const taskStart = new Date(currentDate);
                const taskEnd = new Date(currentDate);
                taskEnd.setDate(taskEnd.getDate() + 1);

                if (!gantt.isTaskExists(taskId)) {
                    const task = {
                        id: taskId,
                        text: '',
                        start_date: taskStart,
                        end_date: taskEnd,
                        duration: 1,
                        progress: 0,
                        parent: 0,
                        type: 'task',
                        readonly: true,
                        editable: false,
                        open: false,
                        $css: 'timeline_hidden_task'
                    };

                    gantt.silent(function() {
                        try {
                            gantt.addTask(task, 0);
                        } catch(e) {
                            console.log('Could not add weekly task:', e);
                        }
                    });
                }

                // Move to next week (7 days instead of 14)
                currentDate.setDate(currentDate.getDate() + 7);
                taskIndex++;
            }

            // Strategy 2: Daily tasks for the last two weeks of December
            console.log('Adding daily tasks for late December...');
            for (let day = 15; day <= 31; day++) {
                const dailyTaskId = '_tl_dec_' + day;
                const dailyDate = new Date(2025, 11, day);

                if (!gantt.isTaskExists(dailyTaskId)) {
                    gantt.silent(function() {
                        try {
                            gantt.addTask({
                                id: dailyTaskId,
                                text: '',
                                start_date: dailyDate,
                                end_date: new Date(dailyDate.getTime() + 86400000),
                                duration: 1,
                                progress: 0,
                                parent: 0,
                                type: 'task',
                                readonly: true,
                                editable: false,
                                $css: 'timeline_hidden_task'
                            }, 0);
                        } catch(e) {
                            console.log('Could not add December daily task:', e);
                        }
                    });
                }
            }

            // Strategy 3: Add tasks BEYOND December 31 to force extension
            console.log('Adding tasks beyond December 31 to force extension...');
            const beyondTasks = [
                { id: '_tl_jan_2026_01', date: new Date(2026, 0, 1) },
                { id: '_tl_jan_2026_02', date: new Date(2026, 0, 2) },
                { id: '_tl_jan_2026_03', date: new Date(2026, 0, 3) },
                { id: '_tl_jan_2026_07', date: new Date(2026, 0, 7) }
            ];

            beyondTasks.forEach(function(bt) {
                if (!gantt.isTaskExists(bt.id)) {
                    gantt.silent(function() {
                        try {
                            gantt.addTask({
                                id: bt.id,
                                text: '',
                                start_date: bt.date,
                                end_date: new Date(bt.date.getTime() + 86400000),
                                duration: 1,
                                progress: 0,
                                parent: 0,
                                type: 'task',
                                readonly: true,
                                editable: false,
                                $css: 'timeline_hidden_task'
                            }, 0);
                        } catch(e) {
                            console.log('Could not add beyond task:', e);
                        }
                    });
                }
            });

            console.log('Created', taskIndex + 17 + 4, 'timeline forcing tasks (weekly + December daily + beyond)');
        } else {
            // For Month/Year views, just create monthly tasks
            for (let month = 0; month < 12; month++) {
                const taskId = '_tl_m_' + month;

                if (!gantt.isTaskExists(taskId)) {
                    const task = {
                        id: taskId,
                        text: '',
                        start_date: new Date(2025, month, 15),
                        end_date: new Date(2025, month, 16),
                        duration: 1,
                        progress: 0,
                        parent: 0,
                        type: 'task',
                        readonly: true,
                        editable: false,
                        $css: 'timeline_hidden_task'
                    };

                    gantt.silent(function() {
                        gantt.addTask(task, 0);
                    });
                }
            }
        }

        // Always add boundary tasks - extend beyond Dec 31 to force timeline
        const boundaryTasks = [
            { id: '_tl_start_', date: new Date(2025, 0, 1) },
            { id: '_tl_dec_30_', date: new Date(2025, 11, 30) },
            { id: '_tl_dec_31_', date: new Date(2025, 11, 31) },
            { id: '_tl_jan_01_2026_', date: new Date(2026, 0, 1) },
            { id: '_tl_jan_15_2026_', date: new Date(2026, 0, 15) }
        ];

        boundaryTasks.forEach(function(boundary) {
            if (!gantt.isTaskExists(boundary.id)) {
                gantt.silent(function() {
                    gantt.addTask({
                        id: boundary.id,
                        text: '',
                        start_date: boundary.date,
                        end_date: new Date(boundary.date.getTime() + 86400000),
                        duration: 1,
                        progress: 0,
                        parent: 0,
                        type: 'task',
                        readonly: true,
                        editable: false,
                        $css: 'timeline_hidden_task'
                    }, 0);
                });
            }
        });
    }

    // Override multiple internal methods to force timeline
    gantt._get_tasks_data = function() {
        const tasks = gantt.getTaskByTime();
        // Always include boundary dates in calculation
        const boundaryStart = {
            start_date: new Date(2025, 0, 1),
            end_date: new Date(2025, 0, 2)
        };
        const boundaryEnd = {
            start_date: new Date(2025, 11, 30),
            end_date: new Date(2026, 0, 7, 23, 59, 59)
        };
        return [boundaryStart, ...tasks, boundaryEnd];
    };

    // Override the getSubtaskDates to always return full year range
    const originalGetSubtaskDates = gantt.getSubtaskDates;
    gantt.getSubtaskDates = function(task_id) {
        const result = originalGetSubtaskDates.call(this, task_id);
        // For root level (0), always return full year 2025
        if (task_id === 0 || task_id === undefined) {
            result.start_date = new Date(2025, 0, 1);
            result.end_date = new Date(2026, 0, 7, 23, 59, 59);
        }
        return result;
    };

    // Override _getProjectEnd to always return extended date
    gantt._getProjectEnd = function() {
        return new Date(2026, 0, 7, 23, 59, 59);
    };

    // Override _getProjectStart to always return Jan 1, 2025
    gantt._getProjectStart = function() {
        return new Date(2025, 0, 1);
    };

    // Override scale calculation methods
    const originalCalculateScaleRange = gantt._calculateScaleRange;
    if (originalCalculateScaleRange) {
        gantt._calculateScaleRange = function(config) {
            // Force our dates
            config = config || {};
            config.start_date = new Date(2025, 0, 1);
            config.end_date = new Date(2026, 0, 7, 23, 59, 59);

            const result = originalCalculateScaleRange.call(this, config);

            // Ensure result uses our dates
            if (result) {
                result.start_date = new Date(2025, 0, 1);
                result.end_date = new Date(2026, 0, 7, 23, 59, 59);
            }

            return result;
        };
    }

    // Force the timeline with real tasks
    forceTimelineExtension();

    // Initial render
    gantt.render();

    // Double-check timeline extension after render
    setTimeout(function() {
        console.log('Double-checking timeline extension...');
        forceTimelineExtension();
        gantt.render();
    }, 500);

    // Attach event to maintain timeline after any operation
    gantt.attachEvent("onGanttRender", function() {
        gantt.config.start_date = new Date(2025, 0, 1);
        gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59); // Extend to Jan 7, 2026
        gantt.config.fit_tasks = false;
    });

    // Hide timeline forcing tasks in UI
    gantt.templates.task_class = function(start, end, task) {
        if (task.id && task.id.toString().startsWith('_tl_')) {
            return "timeline_hidden_task";
        }
        if (task.$css) {
            return task.$css;
        }
        return "";
    };

    gantt.templates.grid_row_class = function(start, end, task) {
        if (task.id && task.id.toString().startsWith('_tl_')) {
            return "timeline_hidden_task";
        }
        return "";
    };

    gantt.templates.task_text = function(start, end, task) {
        if (task.id && task.id.toString().startsWith('_tl_')) {
            return "";
        }
        return task.text;
    };

    // Hide from grid
    const originalGridTemplate = gantt.templates.grid_folder || function(task) { return ""; };
    gantt.templates.grid_folder = function(task) {
        if (task.id && task.id.toString().startsWith('_tl_')) {
            return "";
        }
        return originalGridTemplate(task);
    };

    // Removed boundary task code - no longer using boundary tasks

    // Ensure month view is applied after initialization
    console.log('=== Setting Month View ===');
    console.log('Before - scale_unit:', gantt.config.scale_unit);
    gantt.config.scale_unit = "month";
    gantt.config.date_scale = "%F %Y";
    gantt.config.subscales = [{unit: "week", step: 1, date: "Week #%W"}];
    gantt.config.min_column_width = 80;
    gantt.config.fit_tasks = false;  // CRITICAL: Don't auto-fit to tasks

    // CRITICAL: Force end date to December 31, 2025 on initial load
    const endOfDec2025 = new Date(2026, 0, 7, 23, 59, 59);
    gantt.config.end_date = endOfDec2025;

    console.log('After - scale_unit:', gantt.config.scale_unit);
    console.log('After - end_date:', gantt.config.end_date.toISOString());
    console.log('After - fit_tasks:', gantt.config.fit_tasks);

    // ========================================================================
    // SET EXPLICIT DATE RANGE - ALWAYS EXTEND TO DEC 31, 2025
    // ========================================================================
    (function() {
        // CRITICAL FIX: Do NOT recalculate start_date from tasks
        // Keep the fixed range: Jan 1, 2025 to Dec 31, 2025 (extended to Jan 7, 2026)
        // This prevents DHTMLX from auto-fitting the timeline

        console.log('=== LOCKING Timeline to Full Year 2025 ===');
        console.log('Start: 2025-01-01');
        console.log('End: 2025-12-31');
        console.log('fit_tasks:', gantt.config.fit_tasks);

        // Verify the configuration is still correct
        if (!gantt.config.start_date || gantt.config.start_date.getFullYear() !== 2025 || gantt.config.start_date.getMonth() !== 0) {
            console.warn('start_date was modified, resetting to Jan 1, 2025');
            gantt.config.start_date = new Date(2025, 0, 1);
        }
        if (!gantt.config.end_date || gantt.config.end_date.getFullYear() !== 2025 || gantt.config.end_date.getMonth() !== 11) {
            console.warn('end_date was modified, resetting to Dec 31, 2025 (extended to Jan 7, 2026)');
            gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59); // Extend to Jan 7, 2026
        }

        // Ensure fit_tasks is false
        gantt.config.fit_tasks = false;

        console.log('Final start_date (UTC):', gantt.config.start_date.toISOString().split('T')[0]);
        console.log('Final start_date (local):', gantt.config.start_date.toString());
        console.log('Final start_date (components):', {
            year: gantt.config.start_date.getFullYear(),
            month: gantt.config.start_date.getMonth(),
            date: gantt.config.start_date.getDate()
        });
        console.log('Final end_date:', gantt.config.end_date.toISOString().split('T')[0]);

        // DISABLED: These renders were overriding our boundary tasks!
        // The render() in the boundary task section is sufficient
        console.log('Skipping extra renders - boundary tasks should handle timeline extension');

        // CRITICAL: Force Gantt to render columns all the way to Dec 31
        // by temporarily showing that date, which forces column generation
        setTimeout(function() {
            console.log('Forcing timeline to render Dec 31, 2025 (extended to Jan 7, 2026) columns...');
            try {
                // Scroll to end date to force column generation
                gantt.showDate(new Date(2025, 11, 31));
                console.log('Scrolled to Dec 31, 2025 (extended to Jan 7, 2026)');

                // Wait a moment for columns to generate, then scroll back to first task
                setTimeout(function() {
                    const firstTask = gantt.getTaskByIndex(0);
                    if (firstTask && firstTask.id != 9999998 && firstTask.id != 9999999) {
                        gantt.showTask(firstTask.id);
                        console.log('Scrolled back to first task:', firstTask.id);
                    }
                }, 300);
            } catch (e) {
                console.error('Error forcing timeline render:', e);
            }
        }, 100);
    })();

    // Debug: Log lightbox configuration
    console.log('=== Gantt initialized successfully ===');
    console.log('Lightbox sections:', gantt.config.lightbox.sections);
    console.log('Read-only mode:', gantt.config.readonly);
    console.log('Double-click to open lightbox should work now. Try clicking a task.');

    // FINAL RENDER: Now that everything is configured and boundary tasks are added
    console.log('=== FINAL RENDER with boundary tasks ===');
    gantt.render();
    console.log('Timeline should now extend to Dec 31, 2025 (extended to Jan 7, 2026)');

    // ========================================================================
    // CRITICAL FIX: FORCE TIMELINE EXTENSION BY OVERRIDING INTERNAL METHODS
    // ========================================================================
    (function() {
        console.log('=== APPLYING AGGRESSIVE TIMELINE FIX ===');

        // Store the original functions
        const originalGetState = gantt.getState;
        const originalGetSubtaskDates = gantt.getSubtaskDates;
        const originalGetSubtaskDuration = gantt.getSubtaskDuration;

        // Override getState to always return our fixed dates
        gantt.getState = function() {
            const state = originalGetState.call(this);
            // Force our date range
            state.min_date = new Date(2025, 0, 1);
            state.max_date = new Date(2026, 0, 7, 23, 59, 59);
            console.log('getState override - forcing dates:', state.min_date, 'to', state.max_date);
            return state;
        };

        // Override getSubtaskDates to include our boundary dates
        gantt.getSubtaskDates = function(task_id) {
            const dates = originalGetSubtaskDates.call(this, task_id);
            // If this is the root task, force our date range
            if (task_id === 0 || !task_id) {
                dates.start_date = new Date(2025, 0, 1);
                dates.end_date = new Date(2026, 0, 7, 23, 59, 59);
                console.log('getSubtaskDates override - forcing full year for root');
            }
            return dates;
        };

        // Override getSubtaskDuration to ensure proper duration
        gantt.getSubtaskDuration = function(task_id) {
            if (task_id === 0 || !task_id) {
                // Return duration for full year
                return 365;
            }
            return originalGetSubtaskDuration.call(this, task_id);
        };

        // Force a complete re-render with our overrides in place
        setTimeout(function() {
            console.log('=== Forcing complete re-render with overrides ===');

            // Reset the config one more time to be sure
            gantt.config.start_date = new Date(2025, 0, 1);
            gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59); // Extend to Jan 7, 2026
            gantt.config.fit_tasks = false;

            // Clear and re-render
            gantt.clearAll();
            gantt.parse(ganttData);

            console.log('Re-render complete with overrides active');
            console.log('Timeline should now DEFINITELY extend to Dec 31, 2025 (extended to Jan 7, 2026)');

            // After re-render, try to scroll to show the full timeline
            setTimeout(function() {
                try {
                    // Try to show a date in December to force column rendering
                    gantt.showDate(new Date(2025, 11, 15));
                    console.log('Scrolled to mid-December to force column rendering');

                    // Then scroll back to the first real task
                    setTimeout(function() {
                        const tasks = gantt.getTaskByTime();
                        const realTasks = tasks.filter(t => !t.is_boundary && t.id != 999998 && t.id != 999999);
                        if (realTasks.length > 0) {
                            gantt.showTask(realTasks[0].id);
                            console.log('Scrolled back to first real task');
                        }
                    }, 500);
                } catch(e) {
                    console.log('Could not scroll to December:', e);
                }
            }, 500);

        }, 1000);

        // Also override the internal _get_timeline_dates if it exists
        if (gantt._get_timeline_dates) {
            const original_get_timeline_dates = gantt._get_timeline_dates;
            gantt._get_timeline_dates = function() {
                const dates = original_get_timeline_dates.call(this);
                dates.start_date = new Date(2025, 0, 1);
                dates.end_date = new Date(2026, 0, 7, 23, 59, 59);
                console.log('_get_timeline_dates override - forcing full year');
                return dates;
            };
        }

        // Override any scale calculation methods
        if (gantt._scale_helpers) {
            const originalGetScaleBounds = gantt._scale_helpers.getScaleBounds;
            if (originalGetScaleBounds) {
                gantt._scale_helpers.getScaleBounds = function() {
                    const bounds = originalGetScaleBounds.apply(this, arguments);
                    bounds.start_date = new Date(2025, 0, 1);
                    bounds.end_date = new Date(2026, 0, 7, 23, 59, 59);
                    console.log('getScaleBounds override - forcing full year');
                    return bounds;
                };
            }
        }

        console.log('=== All overrides installed ===');
    })();

    // ========================================================================
    // ENHANCED DELETE FUNCTIONALITY
    // ========================================================================

    /**
     * Delete task with enhanced confirmation dialog
     * Shows subtasks and dependencies before deletion
     */
    function deleteTaskWithConfirmation(taskId) {
        if (!taskId || typeof taskId !== 'number' || taskId <= 0) {
            console.log('Invalid task ID for deletion:', taskId);
            return;
        }

        const task = gantt.getTask(taskId);

        // First, check what will be deleted
        fetch(`/project-management/{{ project.pk }}/api/gantt/tasks/${taskId}/check-delete/`, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            }
        })
        .then(response => response.json())
        .then(data => {
            if (!data.success) {
                alert('Error checking task deletion: ' + data.error);
                return;
            }

            // Build confirmation message
            let message = `Delete task "${data.task_code}: ${data.task_title}"?\n\n`;

            // Warn about subtasks
            if (data.subtask_count > 0) {
                message += `⚠️  WARNING: This will also delete ${data.subtask_count} subtask(s)!\n`;
                if (data.subtasks.length > 0) {
                    message += '\nSubtasks to be deleted:\n';
                    data.subtasks.forEach(st => {
                        message += `  • ${st.code}: ${st.title}\n`;
                    });
                    if (data.has_more_subtasks) {
                        message += `  ... and ${data.subtask_count - data.subtasks.length} more\n`;
                    }
                }
                message += '\n';
            }

            // Warn about dependencies
            if (data.predecessor_count > 0 || data.successor_count > 0) {
                message += `⚠️  This task has ${data.predecessor_count + data.successor_count} dependency link(s):\n`;

                if (data.predecessors.length > 0) {
                    message += '\nPredecessors (tasks this depends on):\n';
                    data.predecessors.forEach(p => {
                        message += `  ← ${p.code}: ${p.title}\n`;
                    });
                }

                if (data.successors.length > 0) {
                    message += '\nSuccessors (tasks that depend on this):\n';
                    data.successors.forEach(s => {
                        message += `  → ${s.code}: ${s.title}\n`;
                    });
                }
                message += '\nThese dependencies will be removed.\n\n';
            }

            message += '\n⚠️  This action CANNOT be undone!\n\nAre you sure you want to proceed?';

            // Show confirmation dialog
            if (confirm(message)) {
                // User confirmed - proceed with deletion
                gantt.deleteTask(taskId);
            }
        })
        .catch(error => {
            console.error('Error checking task deletion:', error);
            // Fallback to simple confirmation if check fails
            if (confirm(`Delete task "${task.text}"?\n\nWarning: Unable to check subtasks and dependencies.\nThis action cannot be undone.`)) {
                gantt.deleteTask(taskId);
            }
        });
    }

    // ========================================================================
    // KEYBOARD SHORTCUTS
    // ========================================================================

    // Custom keyboard shortcuts for task management
    gantt.attachEvent("onKeyPress", function(code, e) {
        const selectedTaskId = gantt.getSelectedId();

        // Delete key (46) or Backspace (8) - Delete task
        if ((code === 46 || code === 8) && selectedTaskId && !gantt.config.readonly) {
            e.preventDefault();
            const task = gantt.getTask(selectedTaskId);

            // Enhanced delete with pre-check
            deleteTaskWithConfirmation(selectedTaskId);
            return false;
        }

        // Ctrl + Up Arrow - Move task up
        if (code === 38 && e.ctrlKey && selectedTaskId && !gantt.config.readonly) {
            e.preventDefault();
            moveTaskUp(selectedTaskId);
            return false;
        }

        // Ctrl + Down Arrow - Move task down
        if (code === 40 && e.ctrlKey && selectedTaskId && !gantt.config.readonly) {
            e.preventDefault();
            moveTaskDown(selectedTaskId);
            return false;
        }

        // Ctrl + Left Arrow - Decrease indent (promote)
        if (code === 37 && e.ctrlKey && selectedTaskId && !gantt.config.readonly) {
            e.preventDefault();
            changeTaskIndent(selectedTaskId, 'decrease');
            return false;
        }

        // Ctrl + Right Arrow - Increase indent (demote)
        if (code === 39 && e.ctrlKey && selectedTaskId && !gantt.config.readonly) {
            e.preventDefault();
            changeTaskIndent(selectedTaskId, 'increase');
            return false;
        }

        return true;
    });

    // Helper functions for task reordering
    function moveTaskUp(taskId) {
        const task = gantt.getTask(taskId);
        const parent = task.parent;
        const siblings = gantt.getChildren(parent);
        const currentIndex = siblings.indexOf(taskId);

        if (currentIndex > 0) {
            const previousTaskId = siblings[currentIndex - 1];
            const previousTask = gantt.getTask(previousTaskId);

            // Swap orders
            const tempOrder = task.order;
            task.order = previousTask.order - 1;
            gantt.updateTask(taskId);

            // Update on server
            fetch(`/project-management/{{ project.pk }}/api/gantt/tasks/${taskId}/reorder/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrftoken
                },
                body: JSON.stringify({
                    parent: parent || 0,
                    target: previousTaskId,
                    position: 'before'
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    gantt.render();
                    gantt.selectTask(taskId);
                } else {
                    console.error('Error moving task:', data.error);
                    task.order = tempOrder;
                    gantt.updateTask(taskId);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                task.order = tempOrder;
                gantt.updateTask(taskId);
            });
        }
    }

    function moveTaskDown(taskId) {
        const task = gantt.getTask(taskId);
        const parent = task.parent;
        const siblings = gantt.getChildren(parent);
        const currentIndex = siblings.indexOf(taskId);

        if (currentIndex < siblings.length - 1) {
            const nextTaskId = siblings[currentIndex + 1];
            const nextTask = gantt.getTask(nextTaskId);

            // Swap orders
            const tempOrder = task.order;
            task.order = nextTask.order + 1;
            gantt.updateTask(taskId);

            // Update on server
            fetch(`/project-management/{{ project.pk }}/api/gantt/tasks/${taskId}/reorder/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrftoken
                },
                body: JSON.stringify({
                    parent: parent || 0,
                    target: nextTaskId,
                    position: 'after'
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    gantt.render();
                    gantt.selectTask(taskId);
                } else {
                    console.error('Error moving task:', data.error);
                    task.order = tempOrder;
                    gantt.updateTask(taskId);
                }
            })
            .catch(error => {
                console.error('Error:', error);
                task.order = tempOrder;
                gantt.updateTask(taskId);
            });
        }
    }

    function changeTaskIndent(taskId, direction) {
        const task = gantt.getTask(taskId);
        const currentParent = task.parent;

        if (direction === 'decrease' && currentParent) {
            // Promote task (move to parent's level)
            const parentTask = gantt.getTask(currentParent);
            const newParent = parentTask.parent;

            task.parent = newParent;
            gantt.updateTask(taskId);

            // Update on server
            fetch(`/project-management/{{ project.pk }}/api/gantt/tasks/${taskId}/reorder/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrftoken
                },
                body: JSON.stringify({
                    parent: newParent || 0,
                    target: currentParent,
                    position: 'after'
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    gantt.render();
                    gantt.selectTask(taskId);
                } else {
                    console.error('Error changing indent:', data.error);
                    task.parent = currentParent;
                    gantt.updateTask(taskId);
                }
            });
        } else if (direction === 'increase') {
            // Demote task (make it child of previous sibling)
            const siblings = gantt.getChildren(currentParent);
            const currentIndex = siblings.indexOf(taskId);

            if (currentIndex > 0) {
                const newParentId = siblings[currentIndex - 1];
                task.parent = newParentId;
                gantt.updateTask(taskId);

                // Update on server
                fetch(`/project-management/{{ project.pk }}/api/gantt/tasks/${taskId}/reorder/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': csrftoken
                    },
                    body: JSON.stringify({
                        parent: newParentId,
                        target: null,
                        position: 'last'
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        gantt.render();
                        gantt.selectTask(taskId);
                    } else {
                        console.error('Error changing indent:', data.error);
                        task.parent = currentParent;
                        gantt.updateTask(taskId);
                    }
                });
            }
        }
    }

    // Force scroll state update
    setTimeout(function() {
        gantt.render();
        console.log('Gantt chart rendered and scrollbars updated');
        console.log('');
        console.log('=== KEYBOARD SHORTCUTS ===');
        console.log('Delete/Backspace: Delete selected task');
        console.log('Ctrl + ↑: Move task up');
        console.log('Ctrl + ↓: Move task down');
        console.log('Ctrl + ←: Decrease indent (promote)');
        console.log('Ctrl + →: Increase indent (demote)');
        console.log('=========================');
    }, 100);

    // Debug: Log tasks with Chinese titles
    console.log('=== Gantt Chart Loaded ===');
    console.log('Total tasks:', ganttData.data.length);
    let tasksWithChinese = 0;
    ganttData.data.forEach(function(task) {
        if (task.title_cn && task.title_cn.trim() !== '') {
            console.log('✓ Task with Chinese:', task.text, '→', task.title_cn);
            tasksWithChinese++;
        }
    });
    console.log('Tasks with Chinese titles:', tasksWithChinese);

    if (tasksWithChinese === 0) {
        console.log('%c⚠️ No Chinese titles found in database. Please add Chinese text by editing tasks.', 'color: orange; font-weight: bold;');
        console.log('%cHow to add Chinese text:', 'font-weight: bold;');
        console.log('1. Double-click any task in the Gantt chart');
        console.log('2. Enter Chinese text in the "Task Title (中文)" field');
        console.log('3. Click Save');
        console.log('4. Check console for "Chinese title saved successfully" message');
    }

    // Log scroll state
    console.log('Gantt container height:', document.getElementById('gantt_here').offsetHeight);

    // CSRF token helper
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    const csrftoken = getCookie('csrftoken');

    // Event handlers
    gantt.attachEvent("onAfterTaskAdd", function(id, item){
        // Task was created in Gantt - save to database
        fetch(`/project-management/{{ project.pk }}/api/gantt/tasks/create/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                text: item.text,
                start_date: item.start_date ? gantt.date.date_to_str("%Y-%m-%d")(item.start_date) : null,
                duration: item.duration || 1,
                parent: item.parent || 0
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                const oldId = id;
                const newId = data.task.id;

                // Update the temporary ID with the real database ID
                gantt.changeTaskId(oldId, newId);

                // Update task with all properties
                const task = gantt.getTask(newId);
                task.task_code = data.task.task_code;

                // If there was Chinese title or other data in the temporary task, save it now
                if (item.title_cn || item.process_owner_id || item.definition_of_done) {
                    console.log('Saving additional data for newly created task...');
                    fetch(`/project-management/{{ project.pk }}/api/gantt/tasks/${newId}/update-progress/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': csrftoken
                        },
                        body: JSON.stringify({
                            progress: Math.round((item.progress || 0) * 100),
                            title_cn: item.title_cn || '',
                            process_owner_id: item.process_owner_id || null,
                            definition_of_done: item.definition_of_done || ''
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            console.log('Additional data saved for new task');
                            task.title_cn = item.title_cn;
                            task.process_owner_id = item.process_owner_id;
                            task.definition_of_done = item.definition_of_done;
                        }
                        gantt.refreshTask(newId);
                    })
                    .catch(error => {
                        console.error('Error saving additional data:', error);
                    });
                } else {
                    gantt.refreshTask(newId);
                }

                console.log('Task created successfully:', data.task);
            } else {
                alert('Error creating task: ' + data.error);
                gantt.deleteTask(id);
            }
        })
        .catch(error => {
            console.error('Error creating task:', error);
            alert('Failed to create task. Please try again.');
            gantt.deleteTask(id);
        });

        return true;
    });

    gantt.attachEvent("onAfterTaskDelete", function(id, item){
        // Task was deleted in Gantt - delete from database
        // Only delete if it has a valid database ID (not temporary)
        if (typeof id === 'number' && id > 0) {
            console.log(`Deleting task ${id} from database...`);

            fetch(`/project-management/{{ project.pk }}/api/gantt/tasks/${id}/delete/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrftoken
                }
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(data => {
                        throw new Error(data.error || `HTTP ${response.status}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    console.log('%c✓ Task deleted successfully!', 'color: green; font-weight: bold;');
                    console.log('Details:', data.details);

                    // Show success message to user
                    const msg = data.message +
                               (data.details.subtasks_deleted > 0 ? ` (including ${data.details.subtasks_deleted} subtasks)` : '');

                    // Create temporary success notification
                    const notification = document.createElement('div');
                    notification.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: #28a745;
                        color: white;
                        padding: 15px 20px;
                        border-radius: 5px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                        z-index: 10000;
                        font-family: sans-serif;
                        max-width: 400px;
                    `;
                    notification.innerHTML = `
                        <strong>✓ Deleted Successfully</strong><br>
                        ${msg}
                    `;
                    document.body.appendChild(notification);

                    // Remove notification after 4 seconds
                    setTimeout(() => {
                        notification.style.transition = 'opacity 0.5s';
                        notification.style.opacity = '0';
                        setTimeout(() => notification.remove(), 500);
                    }, 4000);
                } else {
                    console.error('Error deleting task:', data.error);
                    alert(`Failed to delete task: ${data.error}\n\nPlease check the console for details.`);
                }
            })
            .catch(error => {
                console.error('%c✗ Error deleting task:', 'color: red; font-weight: bold;', error);
                alert(`Failed to delete task from database:\n\n${error.message}\n\nThe task has been removed from the view but may still exist in the database.\nPlease refresh the page and try again.`);
            });
        }
        return true;
    });

    // ========================================================================
    // DEPENDENCY/LINK MANAGEMENT EVENTS
    // ========================================================================

    // When a dependency is added (either through UI or drag-and-drop)
    gantt.attachEvent("onAfterLinkAdd", function(id, link){
        console.log('Link added:', link);

        // Map Gantt link type to dependency type string
        const typeMap = {0: 'FS', 1: 'SS', 2: 'FF', 3: 'SF'};
        const depType = typeMap[link.type] || 'FS';

        // Save to database
        fetch(`/project-management/{{ project.pk }}/api/gantt/dependencies/add/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                predecessor_id: link.source,
                successor_id: link.target,
                dependency_type: depType,
                lag_days: 0
            })
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(data => {
                    throw new Error(data.error || `HTTP ${response.status}`);
                });
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                console.log('%c✓ Dependency saved successfully!', 'color: green; font-weight: bold;');
                console.log('Dependency:', data.dependency);

                // Update link ID with database ID if needed
                if (data.dependency.id) {
                    link.db_id = data.dependency.id;
                }
            } else {
                console.error('Error saving dependency:', data.error);
                alert(`Failed to save dependency: ${data.error || 'Unknown error'}`);
                // Remove the link from Gantt since it couldn't be saved
                gantt.deleteLink(id);
            }
        })
        .catch(error => {
            console.error('%c✗ Error saving dependency:', 'color: red; font-weight: bold;', error);
            alert(`Failed to save dependency to database:\n\n${error.message}\n\nThe dependency will be removed.`);
            // Remove the link from Gantt since it couldn't be saved
            gantt.deleteLink(id);
        });

        return true;
    });

    // When a dependency is deleted
    gantt.attachEvent("onAfterLinkDelete", function(id, link){
        console.log('Link deleted:', link);

        // Find the dependency in database by predecessor and successor
        // We need to call the backend to delete it
        fetch(`/project-management/{{ project.pk }}/api/gantt/dependencies/remove/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                predecessor_id: link.source,
                successor_id: link.target
            })
        })
        .then(response => {
            if (!response.ok) {
                return response.json().then(data => {
                    throw new Error(data.error || `HTTP ${response.status}`);
                });
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                console.log('%c✓ Dependency removed successfully!', 'color: green; font-weight: bold;');
            } else {
                console.warn('Warning removing dependency:', data.error);
                // Don't show alert for delete operations, just log the warning
            }
        })
        .catch(error => {
            console.error('%c✗ Error removing dependency:', 'color: red; font-weight: bold;', error);
            // Don't show alert for delete operations, just log the error
        });

        return true;
    });

    gantt.attachEvent("onAfterTaskDrag", function(id, mode, e){
        const task = gantt.getTask(id);

        if (mode === "resize" || mode === "move") {
            // Update task dates via API
            fetch(`/project-management/{{ project.pk }}/api/gantt/tasks/${id}/update-dates/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': csrftoken
                },
                body: JSON.stringify({
                    start_date: gantt.date.date_to_str("%Y-%m-%d")(task.start_date),
                    end_date: gantt.date.date_to_str("%Y-%m-%d")(task.end_date)
                })
            })
            .then(response => response.json())
            .then(data => {
                if (!data.success) {
                    alert('Error: ' + data.error);
                    gantt.undo();
                }
            })
            .catch(error => {
                console.error('Error:', error);
                gantt.undo();
            });
        }
    });

    // Control drag behavior - keep tasks at the same level by default
    let originalParent = null;

    gantt.attachEvent("onBeforeTaskMove", function(id, parent, tindex){
        // Store original parent
        const task = gantt.getTask(id);
        if (originalParent === null) {
            originalParent = task.parent;
        }

        // Keep the task at its original parent level
        // Users should use Ctrl+Left/Right to change hierarchy
        return true;
    });

    gantt.attachEvent("onRowDragEnd", function(id, target){
        // Task was reordered/moved in hierarchy
        const task = gantt.getTask(id);

        // Restore original parent to keep task at same level
        if (originalParent !== null) {
            task.parent = originalParent;
            originalParent = null;  // Reset for next drag
            gantt.updateTask(id);
        }

        fetch(`/project-management/{{ project.pk }}/api/gantt/tasks/${id}/reorder/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                parent: task.parent || 0,
                target: target,
                position: 'after'
            })
        })
        .then(response => response.json())
        .then(data => {
            if (!data.success) {
                console.error('Error reordering task:', data.error);
            }
        })
        .catch(error => {
            console.error('Error reordering task:', error);
        });

        return true;
    });

    gantt.attachEvent("onAfterTaskUpdate", function(id, task){
        // Skip updates for invalid, temporary, or null task IDs
        if (!id || id === 'null' || id === null || id === undefined || id > 1000000000000) {
            console.log('Skipping update for invalid/temporary task ID:', id);
            return true;
        }

        // Update task progress, Chinese title, process owner, and DoD
        fetch(`/project-management/{{ project.pk }}/api/gantt/tasks/${id}/update-progress/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                progress: Math.round(task.progress * 100),
                title_cn: task.title_cn || '',
                process_owner_id: task.process_owner_id || null,
                definition_of_done: task.definition_of_done || ''
            })
        })
        .then(response => {
            if (!response.ok) {
                return response.text().then(text => {
                    console.error('Server error:', text);
                    throw new Error(`HTTP ${response.status}`);
                });
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                // Refresh the task to show updated Chinese text
                gantt.refreshTask(id);
                console.log('Task updated successfully');
            } else {
                console.error('Task update failed:', data.error);
            }
        })
        .catch(error => {
            console.error('Error updating task:', error);
        });
    });

    // Handle lightbox save to update task title, Chinese title, process owner, and DoD
    gantt.attachEvent("onLightboxSave", function(id, task, is_new){
        console.log('Lightbox saved for task:', id);
        console.log('  Is new task:', is_new);
        console.log('  Task title:', task.text);
        console.log('  Chinese title:', task.title_cn);
        console.log('  Process owner ID:', task.process_owner_id);
        console.log('  Definition of Done:', task.definition_of_done);
        console.log('  Start date:', task.start_date);
        console.log('  End date:', task.end_date);
        console.log('  Duration:', task.duration);

        // Skip updates for invalid, temporary, or null task IDs
        if (!id || id === 'null' || id === null || id === undefined || id > 1000000000000) {
            console.log('Skipping lightbox save for invalid/temporary task ID:', id);
            return true;
        }

        // Update task dates first (start_date, end_date)
        if (task.start_date && task.end_date) {
            fetch(`/project-management/{{ project.pk }}/api/gantt/tasks/${id}/update-dates/`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    start_date: gantt.date.date_to_str("%Y-%m-%d")(task.start_date),
                    end_date: gantt.date.date_to_str("%Y-%m-%d")(task.end_date)
                })
            })
            .then(response => {
                if (!response.ok) {
                    return response.text().then(text => {
                        console.error('Server error response (HTTP ' + response.status + '):', text.substring(0, 500));
                        throw new Error('HTTP ' + response.status + ': Failed to save dates');
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    console.log('%c✓ Task dates saved successfully!', 'color: green; font-weight: bold;');
                } else {
                    console.error('Failed to save task dates:', data.error);
                    alert('Failed to save task dates: ' + data.error);
                }
            })
            .catch(error => {
                console.error('%c✗ Error saving task dates:', 'color: red; font-weight: bold;', error);
                alert('Error saving task dates: ' + error.message);
            });
        }

        // Update task with all other fields
        fetch(`/project-management/{{ project.pk }}/api/gantt/tasks/${id}/update-progress/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                text: task.text || '',  // Send the main task title
                progress: Math.round(task.progress * 100),
                title_cn: task.title_cn || '',
                process_owner_id: task.process_owner_id || null,
                definition_of_done: task.definition_of_done || ''
            })
        })
        .then(response => {
            console.log('Response status:', response.status);
            if (!response.ok) {
                return response.text().then(text => {
                    console.error('Server error response:', text);
                    throw new Error(`HTTP ${response.status}: ${text.substring(0, 200)}`);
                });
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                console.log('%c✓ Task data saved successfully!', 'color: green; font-weight: bold;');
                console.log('Task ID:', id);
                console.log('Task title:', task.text);
                console.log('Chinese title:', task.title_cn);
                // Update the task object
                const taskObj = gantt.getTask(id);
                taskObj.text = task.text;
                taskObj.title_cn = task.title_cn;
                // Refresh the task display
                setTimeout(function() {
                    gantt.refreshTask(id);
                    gantt.render();
                }, 100);
            } else {
                console.error('Failed to save task data:', data.error);
                alert('Failed to save task data: ' + data.error);
            }
        })
        .catch(error => {
            console.error('%c✗ Error saving task data:', 'color: red; font-weight: bold;', error);
            alert('Error saving task data. Check console for details.');
        });

        return true;
    });

    // View mode change - use zoom extension if available
    document.querySelectorAll('input[name="viewMode"]').forEach(radio => {
        radio.addEventListener('change', function() {
            console.log('View mode changed to:', this.value);

            // BYPASS zoom extension for Day and Week views
            if ((this.value === 'day' || this.value === 'week') && gantt.ext && gantt.ext.zoom) {
                console.log('BYPASSING zoom extension for', this.value, 'view - using custom implementation');

                // Don't use zoom extension - configure manually
                const viewMode = this.value;

                // Clear and reload everything
                gantt.clearAll();

                // Force configuration
                gantt.config.start_date = new Date(2025, 0, 1);
                gantt.config.end_date = new Date(2026, 0, 15, 23, 59, 59); // Extend even further
                gantt.config.fit_tasks = false;
                gantt.config.show_chart = true;

                // Configure scales manually
                if (viewMode === 'day') {
                    gantt.config.scale_unit = "day";
                    gantt.config.date_scale = "%d %M";
                    gantt.config.subscales = [
                        {unit: "hour", step: 6, date: "%H:00"}
                    ];
                    gantt.config.min_column_width = 50;
                    gantt.config.scale_height = 90;
                } else if (viewMode === 'week') {
                    gantt.config.scale_unit = "week";
                    gantt.config.date_scale = "Week #%W";
                    gantt.config.subscales = [
                        {unit: "day", step: 1, date: "%d %M"}
                    ];
                    gantt.config.min_column_width = 70;
                    gantt.config.scale_height = 90;
                }

                // Re-parse data
                gantt.parse(ganttData);

                // Force timeline extension with tasks
                if (typeof forceTimelineExtension === 'function') {
                    forceTimelineExtension();
                }

                // Force render
                gantt.render();

                // CRITICAL: Force scrolling to generate all columns
                setTimeout(function() {
                    console.log('Forcing column generation by scrolling...');

                    // Scroll to end
                    gantt.showDate(new Date(2026, 0, 7));

                    // Scroll through key dates to force column generation
                    setTimeout(function() {
                        gantt.showDate(new Date(2025, 11, 31)); // Dec 31
                    }, 100);

                    setTimeout(function() {
                        gantt.showDate(new Date(2025, 11, 15)); // Dec 15
                    }, 200);

                    setTimeout(function() {
                        gantt.showDate(new Date(2025, 6, 1)); // July 1
                    }, 300);

                    setTimeout(function() {
                        // Return to first task or current date
                        const firstTask = gantt.getTaskByIndex(0);
                        if (firstTask && firstTask.start_date) {
                            gantt.showTask(firstTask.id);
                        } else {
                            gantt.showDate(new Date());
                        }
                        console.log('Column generation complete');
                    }, 400);
                }, 500);

                console.log('Custom scale configuration applied for', viewMode);
                return; // Don't continue to zoom extension

            } else if (gantt.ext && gantt.ext.zoom) {
                // Use zoom extension for Month and Year views only
                console.log('Using zoom extension for', this.value, 'view');
                gantt.ext.zoom.setLevel(this.value);

                // For Day and Week views, ensure aggressive timeline extension with DATA REFRESH
                if (this.value === 'day' || this.value === 'week') {
                    console.log('Applying DATA REFRESH timeline enforcement for', this.value, 'view');

                    // Critical: Refresh the entire Gantt data after zoom level change
                    setTimeout(function() {
                        console.log('Starting data refresh for full timeline extension...');

                        // Store current position
                        const selectedTask = gantt.getSelectedId();

                        // Clear and reload to force timeline recalculation
                        gantt.clearAll();

                        // Force config settings
                        gantt.config.start_date = new Date(2025, 0, 1);
                        gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59); // Extend to Jan 7, 2026
                        gantt.config.fit_tasks = false;

                        // Re-parse the data
                        gantt.parse(ganttData);

                        // Call forceTimelineExtension to add monthly placeholders
                        if (typeof forceTimelineExtension === 'function') {
                            forceTimelineExtension();
                        }

                        // Restore selection if it existed
                        if (selectedTask && gantt.isTaskExists(selectedTask)) {
                            gantt.selectTask(selectedTask);
                        }

                        console.log('Data refresh complete - timeline should extend to Dec 31, 2025 (extended to Jan 7, 2026)');

                        // Aggressive scrolling pattern for day/week views
                        const dates = [
                            new Date(2025, 11, 31),  // End of year
                            new Date(2025, 6, 1),    // Middle of year
                            new Date(2025, 0, 1)     // Start of year
                        ];

                        let dateIndex = 0;
                        const scrollTimer = setInterval(function() {
                            if (dateIndex < dates.length) {
                                gantt.showDate(dates[dateIndex]);
                                console.log('Force scroll to:', dates[dateIndex].toDateString());
                                dateIndex++;
                            } else {
                                clearInterval(scrollTimer);
                                // Return to first task
                                const firstTask = gantt.getTaskByIndex(0);
                                if (firstTask && firstTask.start_date) {
                                    gantt.showTask(firstTask.id);
                                }
                            }
                        }, 200);
                    }, 800);  // Wait for zoom change to complete
                }

                return;
            }

            // Fallback to manual configuration (if zoom not available)
            switch(this.value) {
                case 'day':
                    gantt.config.scale_unit = "day";
                    gantt.config.date_scale = "%d %M";
                    gantt.config.subscales = [{unit:"hour", step:6, date:"%H"}];
                    gantt.config.min_column_width = 40;
                    break;
                case 'week':
                    gantt.config.scale_unit = "week";
                    gantt.config.date_scale = "Week #%W";
                    gantt.config.subscales = [{unit:"day", step:1, date:"%d %M"}];
                    gantt.config.min_column_width = 60;
                    break;
                case 'month':
                    gantt.config.scale_unit = "month";
                    gantt.config.date_scale = "%F %Y";
                    gantt.config.subscales = [{unit:"week", step:1, date:"Week #%W"}];
                    gantt.config.min_column_width = 80;
                    break;
                case 'year':
                    gantt.config.scale_unit = "year";
                    gantt.config.date_scale = "%Y";
                    gantt.config.subscales = [{unit:"month", step:1, date:"%M"}];
                    gantt.config.min_column_width = 100;
                    break;
            }

            // CRITICAL: Always ensure timeline extends to full year 2025
            // This must be set AFTER scale configuration and BEFORE render
            const startOfJan2025 = new Date(2025, 0, 1);
            const endOfDec2025 = new Date(2026, 0, 7, 23, 59, 59);
            gantt.config.start_date = startOfJan2025;  // Lock to Jan 1, 2025
            gantt.config.end_date = endOfDec2025;  // Lock to Dec 31, 2025 (extended to Jan 7, 2026)
            gantt.config.fit_tasks = false;  // Ensure fit_tasks stays disabled

            console.log('View mode applied. Start date:', gantt.config.start_date.toISOString());
            console.log('View mode applied. End date:', gantt.config.end_date.toISOString());
            console.log('fit_tasks:', gantt.config.fit_tasks);

            // Force timeline to extend by setting config and refreshing
            console.log('Forcing timeline extension through config...');

            // Re-apply the overrides to ensure timeline extends
            gantt._getProjectEnd = function() {
                return new Date(2026, 0, 7, 23, 59, 59);
            };
            gantt._getProjectStart = function() {
                return new Date(2025, 0, 1);
            };

            // Force Gantt to render with full year timeline
            gantt.render();

            // WORKAROUND: Scroll to show that the end date exists in the timeline
            // This forces Gantt to render columns all the way to Dec 31
            // Wait for render operations to complete before scrolling
            setTimeout(() => {
                gantt.showDate(endOfDec2025);
                console.log('Scrolled to December 31, 2025 to force timeline extension');
                // Then scroll back to show tasks
                setTimeout(() => {
                    if (gantt.getTaskByIndex(0)) {
                        gantt.showTask(gantt.getTaskByIndex(0).id);
                        console.log('Scrolled back to first task');
                    }
                }, 500);  // Give time to see the full timeline
            }, 1500);  // Wait for all render operations to complete
        });
    });

    // Ensure Month button is checked on page load
    const monthButton = document.getElementById('viewMonth');
    if (monthButton && !monthButton.checked) {
        console.log('Month button not checked, checking it now');
        monthButton.checked = true;
    }

    // Handle Force Full Year button - ENHANCED VERSION WITH DATA REFRESH
    document.getElementById('forceFullYear').addEventListener('click', function(e) {
        e.preventDefault();
        console.log('=== FORCING FULL YEAR TIMELINE WITH DATA REFRESH ===');

        const currentLevel = document.querySelector('input[name="viewMode"]:checked')?.value || 'month';
        const selectedTask = gantt.getSelectedId();

        // Step 1: Clear and refresh data completely
        console.log('Clearing and refreshing all data...');
        gantt.clearAll();

        // Step 2: Force config settings
        gantt.config.start_date = new Date(2025, 0, 1);
        gantt.config.end_date = new Date(2026, 0, 7, 23, 59, 59); // Extend to Jan 7, 2026
        gantt.config.fit_tasks = false;
        gantt.config.show_chart = true;

        // Step 3: Re-parse data
        gantt.parse(ganttData);

        // Step 4: Add timeline extension placeholders
        if (typeof forceTimelineExtension === 'function') {
            forceTimelineExtension();
        }

        // Step 5: If zoom extension exists, reconfigure current level
        if (gantt.ext && gantt.ext.zoom) {
            console.log('Reconfiguring zoom level:', currentLevel);
            gantt.ext.zoom.setLevel(currentLevel);
        }

        // Step 6: Restore selection
        if (selectedTask && gantt.isTaskExists(selectedTask)) {
            gantt.selectTask(selectedTask);
        }

        // Step 3: Force timeline to render all columns
        setTimeout(function() {
            // Scroll to end of year
            gantt.showDate(new Date(2025, 11, 31));
            console.log('Scrolled to December 31, 2025');

            // Scroll to middle of year
            setTimeout(function() {
                gantt.showDate(new Date(2025, 6, 1));
                console.log('Scrolled to July 1, 2025');

                // Finally scroll to start or first task
                setTimeout(function() {
                    const firstTask = gantt.getTaskByIndex(0);
                    if (firstTask && firstTask.start_date) {
                        gantt.showTask(firstTask.id);
                        console.log('Scrolled back to first task');
                    } else {
                        gantt.showDate(new Date(2025, 0, 1));
                        console.log('Scrolled to January 1, 2025');
                    }
                }, 300);
            }, 300);
        }, 500);

        // Show success message
        this.innerHTML = '<i class="fas fa-check"></i> Full Year Applied';
        setTimeout(() => {
            this.innerHTML = '<i class="fas fa-expand-arrows-alt"></i> Force Full Year';
        }, 3000);
    });

    // Handle timeline markers visibility toggle
    // Note: This toggle is disabled since markers are now completely hidden
    const toggleBtn = document.getElementById('toggleTimelineMarkers');
    if (toggleBtn) {
        // Hide the toggle since timeline markers are now invisible
        toggleBtn.parentElement.style.display = 'none';
    }

    // Toggle options
    document.getElementById('showCritical').addEventListener('change', function() {
        gantt.config.highlight_critical_path = this.checked;
        gantt.render();
    });

    document.getElementById('showDeps').addEventListener('change', function() {
        gantt.config.show_links = this.checked;
        gantt.render();
    });

    document.getElementById('showProgress').addEventListener('change', function() {
        gantt.config.show_progress = this.checked;
        gantt.render();
    });

    // Baseline selection
    {% if baselines %}
    document.getElementById('baselineSelect').addEventListener('change', function() {
        const baselineId = this.value;
        const url = new URL(window.location);
        if (baselineId) {
            url.searchParams.set('baseline', baselineId);
        } else {
            url.searchParams.delete('baseline');
        }
        window.location.href = url.toString();
    });
    {% endif %}

    // Modal functions
    function showCreateBaselineModal() {
        const modal = new bootstrap.Modal(document.getElementById('createBaselineModal'));
        modal.show();
    }

    function showDependencyModal() {
        const modal = new bootstrap.Modal(document.getElementById('dependencyModal'));
        modal.show();
    }

    function createBaseline() {
        const name = document.getElementById('baselineName').value.trim();
        const description = document.getElementById('baselineDescription').value.trim();

        if (!name) {
            alert('Please enter a baseline name');
            return;
        }

        fetch(`/project-management/{{ project.pk }}/api/gantt/baselines/create/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                name: name,
                description: description
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                alert('Baseline created successfully!');
                location.reload();
            } else {
                alert('Error: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Failed to create baseline');
        });
    }

    function addDependency() {
        const predecessorId = document.getElementById('predecessorTask').value;
        const successorId = document.getElementById('successorTask').value;
        const dependencyType = document.getElementById('dependencyType').value;
        const lagDays = document.getElementById('lagDays').value;

        if (!predecessorId || !successorId) {
            alert('Please select both predecessor and successor tasks');
            return;
        }

        if (predecessorId === successorId) {
            alert('A task cannot depend on itself');
            return;
        }

        fetch(`/project-management/{{ project.pk }}/api/gantt/dependencies/add/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrftoken
            },
            body: JSON.stringify({
                predecessor_id: predecessorId,
                successor_id: successorId,
                dependency_type: dependencyType,
                lag_days: parseInt(lagDays) || 0
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                alert('Dependency added successfully!');
                location.reload();
            } else {
                alert('Error: ' + data.error);
            }
        })
        .catch(error => {
            console.error('Error:', error);
            alert('Failed to add dependency');
        });
    }

    // ============================================================================
    // TASK SEARCH FUNCTIONALITY
    // ============================================================================

    let searchMatchedTasks = [];
    let currentSearchIndex = 0;

    function searchTasks() {
        const searchInput = document.getElementById('taskSearch');
        const searchTerm = searchInput.value.trim().toLowerCase();

        if (!searchTerm) {
            clearSearch();
            return;
        }

        // Split search term into individual words
        const searchWords = searchTerm.split(/\s+/).filter(word => word.length > 0);

        // Find matching tasks
        searchMatchedTasks = [];
        gantt.eachTask(function(task) {
            const taskText = task.text.toLowerCase();
            const taskCode = task.task_code.toLowerCase();
            const taskCn = task.title_cn ? task.title_cn.toLowerCase() : '';

            // Check if ANY of the search words matches
            const hasMatch = searchWords.some(word => {
                return taskText.includes(word) ||
                       taskCode.includes(word) ||
                       taskCn.includes(word);
            });

            if (hasMatch) {
                searchMatchedTasks.push(task.id);
            }
        });

        if (searchMatchedTasks.length > 0) {
            currentSearchIndex = 0;
            highlightSearchResults();
            navigateToSearchResult(0);
            showSearchResults();
        } else {
            clearSearch();
            alert('No tasks found matching "' + searchInput.value + '"');
        }
    }

    function highlightSearchResults() {
        // Clear previous highlights
        gantt.eachTask(function(task) {
            const row = gantt.getTaskNode(task.id);
            if (row) {
                row.classList.remove('search_match', 'search_selected');
            }
        });

        // Highlight all matches
        searchMatchedTasks.forEach(function(taskId) {
            const row = gantt.getTaskNode(taskId);
            if (row) {
                row.classList.add('search_match');
            }
        });

        // Force refresh to show highlights
        gantt.render();
    }

    function navigateToSearchResult(index) {
        if (searchMatchedTasks.length === 0) return;

        // Remove previous selection
        gantt.eachTask(function(task) {
            const row = gantt.getTaskNode(task.id);
            if (row) {
                row.classList.remove('search_selected');
            }
        });

        // Select current task
        const taskId = searchMatchedTasks[index];
        const row = gantt.getTaskNode(taskId);
        if (row) {
            row.classList.add('search_selected');
        }

        // Select in gantt and scroll to it
        gantt.selectTask(taskId);
        gantt.showTask(taskId);

        // Update search results display
        showSearchResults();
    }

    function showSearchResults() {
        const resultsDiv = document.getElementById('searchResults');
        const clearBtn = document.getElementById('clearSearchBtn');

        if (searchMatchedTasks.length > 0) {
            resultsDiv.textContent = `Found ${searchMatchedTasks.length} task${searchMatchedTasks.length > 1 ? 's' : ''} (${currentSearchIndex + 1}/${searchMatchedTasks.length})`;
            resultsDiv.style.display = 'block';
            clearBtn.style.display = 'inline-block';
        } else {
            resultsDiv.style.display = 'none';
            clearBtn.style.display = 'none';
        }
    }

    function clearSearch() {
        // Clear search input
        document.getElementById('taskSearch').value = '';

        // Clear highlights
        gantt.eachTask(function(task) {
            const row = gantt.getTaskNode(task.id);
            if (row) {
                row.classList.remove('search_match', 'search_selected');
            }
        });

        // Reset search state
        searchMatchedTasks = [];
        currentSearchIndex = 0;

        // Hide results
        document.getElementById('searchResults').style.display = 'none';
        document.getElementById('clearSearchBtn').style.display = 'none';

        // Unselect task
        gantt.unselectTask();

        // Force refresh
        gantt.render();
    }

    function nextSearchResult() {
        if (searchMatchedTasks.length === 0) return;

        currentSearchIndex = (currentSearchIndex + 1) % searchMatchedTasks.length;
        navigateToSearchResult(currentSearchIndex);
    }

    function previousSearchResult() {
        if (searchMatchedTasks.length === 0) return;

        currentSearchIndex = (currentSearchIndex - 1 + searchMatchedTasks.length) % searchMatchedTasks.length;
        navigateToSearchResult(currentSearchIndex);
    }

    // Add keyboard shortcuts for search
    document.getElementById('taskSearch').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
            e.preventDefault();
            if (searchMatchedTasks.length > 0 && this.value === '') {
                // If already searching and Enter pressed on empty field, go to next result
                nextSearchResult();
            } else {
                // Otherwise, perform new search
                searchTasks();
            }
        }
    });

    // Add keyboard shortcuts for navigation when search is active
    document.addEventListener('keydown', function(e) {
        if (searchMatchedTasks.length > 0) {
            if (e.key === 'ArrowDown' && e.ctrlKey) {
                e.preventDefault();
                nextSearchResult();
            } else if (e.key === 'ArrowUp' && e.ctrlKey) {
                e.preventDefault();
                previousSearchResult();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                clearSearch();
            }
        }
    });

    // Add navigation buttons if multiple results
    function addSearchNavigation() {
        const searchDiv = document.getElementById('taskSearch').parentElement;

        // Check if navigation buttons already exist
        if (document.getElementById('searchNavButtons')) return;

        const navButtons = document.createElement('div');
        navButtons.id = 'searchNavButtons';
        navButtons.className = 'btn-group btn-group-sm ms-2';
        navButtons.style.display = 'none';
        navButtons.innerHTML = `
            <button class="btn btn-outline-secondary" type="button" onclick="previousSearchResult()" title="Previous (Ctrl+↑)">
                <i class="fas fa-chevron-up"></i>
            </button>
            <button class="btn btn-outline-secondary" type="button" onclick="nextSearchResult()" title="Next (Ctrl+↓)">
                <i class="fas fa-chevron-down"></i>
            </button>
        `;

        searchDiv.parentElement.appendChild(navButtons);
    }

    // Show/hide navigation buttons based on search results
    function updateSearchNavigation() {
        const navButtons = document.getElementById('searchNavButtons');
        if (navButtons) {
            navButtons.style.display = searchMatchedTasks.length > 1 ? 'inline-flex' : 'none';
        }
    }

    // Initialize search navigation on page load
    setTimeout(function() {
        addSearchNavigation();
    }, 500);

    // Update the showSearchResults function to show navigation buttons
    const originalShowSearchResults = showSearchResults;
    showSearchResults = function() {
        originalShowSearchResults();
        updateSearchNavigation();
    };

    // ============================================================================
    // CHART HEIGHT ADJUSTMENT
    // ============================================================================

    const CHART_HEIGHT_KEY = 'gantt_chart_height';
    const MIN_HEIGHT = 400;
    const MAX_HEIGHT = 1600;
    const HEIGHT_STEP = 100;
    let currentChartHeight = 700;

    // Load saved height from localStorage
    function loadChartHeight() {
        const savedHeight = localStorage.getItem(CHART_HEIGHT_KEY);
        if (savedHeight) {
            currentChartHeight = parseInt(savedHeight);
        } else {
            currentChartHeight = 700; // Default height
        }
        applyChartHeight();
    }

    // Save height to localStorage
    function saveChartHeight() {
        localStorage.setItem(CHART_HEIGHT_KEY, currentChartHeight);
    }

    // Apply the chart height
    function applyChartHeight() {
        const ganttContainer = document.getElementById('gantt_here');
        if (ganttContainer) {
            ganttContainer.style.height = currentChartHeight + 'px';
        }

        // Update button text
        const heightBtn = document.getElementById('currentHeightBtn');
        if (heightBtn) {
            heightBtn.textContent = currentChartHeight + 'px';
        }

        // Re-render gantt to adjust to new height
        if (typeof gantt !== 'undefined') {
            gantt.render();
        }
    }

    // Adjust chart height
    function adjustChartHeight(direction) {
        if (direction === 'increase') {
            currentChartHeight = Math.min(currentChartHeight + HEIGHT_STEP, MAX_HEIGHT);
        } else if (direction === 'decrease') {
            currentChartHeight = Math.max(currentChartHeight - HEIGHT_STEP, MIN_HEIGHT);
        }

        applyChartHeight();
        saveChartHeight();
    }

    // Reset to default height (optional - can be added as a button if needed)
    function resetChartHeight() {
        currentChartHeight = 700;
        applyChartHeight();
        saveChartHeight();
    }

    // Add double-click to reset height
    document.addEventListener('DOMContentLoaded', function() {
        const heightBtn = document.getElementById('currentHeightBtn');
        if (heightBtn) {
            heightBtn.addEventListener('dblclick', function() {
                if (confirm('Reset chart height to default (700px)?')) {
                    resetChartHeight();
                }
            });
            heightBtn.title = 'Double-click to reset to default (700px)';
        }
    });

    // Initialize height on page load
    setTimeout(function() {
        loadChartHeight();
    }, 100);

    // Add keyboard shortcuts for height adjustment
    document.addEventListener('keydown', function(e) {
        // Ctrl + Shift + Up: Increase height
        if (e.ctrlKey && e.shiftKey && e.key === 'ArrowUp') {
            e.preventDefault();
            adjustChartHeight('increase');
        }
        // Ctrl + Shift + Down: Decrease height
        else if (e.ctrlKey && e.shiftKey && e.key === 'ArrowDown') {
            e.preventDefault();
            adjustChartHeight('decrease');
        }
    });
</script>
{% endblock %}
